// Copyright 2025. Team Unique Turtle ; https://github.com/biomaticals. All rights reserved.
// All contents cannot be copied, distributed, revised.

Code 14-1
Input:
void UTOutputWindow::Code_14_1_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glfwSetKeyCallback(GetGLFWWindow(), UTOutputWindow::Code_14_1_Key);

	QuardricObj_14_1 = gluNewQuadric();

	GLfloat mat_diffuse[] = { 1.f, 1.f, 0.9f, 1.f };
	GLfloat mat_specular[] = { 1.f, 1.f, 1.f, 1.f };
	GLfloat light_position[] = { 2.5f, 2.5f, -15.f, 1.f };

	glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
	glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
	glMaterialf(GL_FRONT, GL_SHININESS, 25.f);
	glLightfv(GL_LIGHT0, GL_POSITION, light_position);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);

	MAIN_WINDOW->ExplanationContext = L"GLU 쿼드릭 객체를 사용해 구, 원판, 부분원판, 원기둥등의 2차 곡면을 그리는 예제입니다.\n";
	MAIN_WINDOW->DebugContext = L"1: 구, 2: 원판, 3: 부분원판, 4: 원기둥\n5: 그리기 스타일 변경(점->선->채우기)";
}

void UTOutputWindow::Code_14_1()
{
	glfwMakeContextCurrent(GetGLFWWindow());

	int display_w{}, display_h{};
	glfwGetWindowSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);

	glClearColor(0.f, 0.f, 0.f, 0.f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(40.f, (GLfloat)display_w / (GLfloat)display_h, 1.f, 10.f);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	gluLookAt(0.f, 0.f, 5.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f);
	glTranslatef(0.f, 0.f, -1.f);

	glShadeModel(GL_SMOOTH);
	gluQuadricNormals(QuardricObj_14_1, GLU_SMOOTH);

	if (bDrawStyle_14_1 == 1 << 0)
		gluQuadricDrawStyle(QuardricObj_14_1, GLU_POINT);
	else if (bDrawStyle_14_1 == 1 << 1)
		gluQuadricDrawStyle(QuardricObj_14_1, GLU_LINE);
	else if (bDrawStyle_14_1 == 1 << 2)
		gluQuadricDrawStyle(QuardricObj_14_1, GLU_FILL);

	if (bDrawingShape_14_1 == 1 << 0)
	{
		gluSphere(QuardricObj_14_1, 1.f, 20, 20);
		gluQuadricOrientation(QuardricObj_14_1, GLU_OUTSIDE);
	}
	else if (bDrawingShape_14_1 == 1 << 1)
	{
		gluDisk(QuardricObj_14_1, 0.5f, 1.f, 20, 4);
		gluQuadricOrientation(QuardricObj_14_1, GLU_INSIDE);
	}

	else if (bDrawingShape_14_1 == 1 << 2)
	{
		gluPartialDisk(QuardricObj_14_1, 0.5f, 1.f, 20, 4, 0.f, 270.f);
		gluQuadricOrientation(QuardricObj_14_1, GLU_INSIDE);
	}
	else if (bDrawingShape_14_1 == 1 << 3)
	{
		gluCylinder(QuardricObj_14_1, 0.5f, 0.2f, 2.f, 20, 4);
		gluQuadricOrientation(QuardricObj_14_1, GLU_OUTSIDE);
	}
	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_14_1_End()
{
	ResetAll();
	glfwMakeContextCurrent(GetGLFWWindow());
	glfwSetKeyCallback(GetGLFWWindow(), nullptr);

	gluDeleteQuadric(QuardricObj_14_1);

	MAIN_WINDOW->ExplanationContext = L"";
	MAIN_WINDOW->DebugContext = L"";
}

void UTOutputWindow::Code_14_1_Key(GLFWwindow* Window, int Key, int Scancode, int Action, int Mods)
{
	if (Action != GLFW_PRESS)
		return;

	switch (Key)
	{
	case GLFW_KEY_1:
	{
		OUTPUT_WINDOW->bDrawingShape_14_1 = 1 << 0;
		break;
	}
	case GLFW_KEY_2:
	{
		OUTPUT_WINDOW->bDrawingShape_14_1 = 1 << 1;
		break;

	}
	case GLFW_KEY_3:
	{
		OUTPUT_WINDOW->bDrawingShape_14_1 = 1 << 2;
		break;
	}
	case GLFW_KEY_4:
	{
		OUTPUT_WINDOW->bDrawingShape_14_1 = 1 << 3;
		break;
	}
	case GLFW_KEY_5:
	{
		OUTPUT_WINDOW->bDrawStyle_14_1 = OUTPUT_WINDOW->bDrawStyle_14_1 << 1;
		if (OUTPUT_WINDOW->bDrawStyle_14_1 > (1 << 2))
			OUTPUT_WINDOW->bDrawStyle_14_1 = 1 << 0;
		break;
	}
	default:
		break;
	}
}
Description:
gluNewQuadric은 새로운 쿼드릭 객체를 생성하고 그 객체에 대한 포인터를 반환하는 함수입니다. 쿼드릭 객체는 구, 원판, 원기둥 등의 3D 기하학적 도형을 그리는 데 사용됩니다.
gluDeleteQuadric은 생성된 쿼드릭 객체를 삭제하는 함수입니다. 메모리 누수를 방지하기 위해 사용 후 반드시 호출해야 합니다.

gluQuadricNormals 함수는 쿼드릭 객체에 대한 법선 벡터의 생성을 설정합니다. GLU_SMOOTH, GLU_FLAT, GLU_NONE 등의 옵션을 사용할 수 있습니다. 
GLU_SMOOTH는 부드러운 음영 처리를 위해 법선을 생성합니다.

gluQuadricDrawStyle 함수는 쿼드릭 객체의 그리기 스타일을 설정합니다. GLU_POINT, GLU_LINE, GLU_FILL, GLU_SILHOUETTE 등의 옵션이 있습니다.
예를 들어, GLU_POINT는 점으로 도형을 그리며, GLU_FILL은 채워진 도형을 그립니다.

gluQuadricOrientation 함수는 쿼드릭 객체의 방향을 설정합니다. GLU_OUTSIDE와 GLU_INSIDE 옵션이 있으며, 이는 도형의 앞면과 뒷면을 결정합니다.

gluSphere 함수는 쿼드릭 객체를 사용하여 구를 그리는 함수입니다. 반지름과 세그먼트 수를 지정하여 구의 세부 사항을 조절할 수 있습니다.
gluDisk 함수는 쿼드릭 객체를 사용하여 원판을 그리는 함수입니다. 내부 반지름과 외부 반지름을 지정하여 원판의 크기를 조절할 수 있습니다.
gluPartialDisk 함수는 쿼드릭 객체를 사용하여 부분 원판을 그리는 함수입니다. 내부 반지름, 외부 반지름, 시작 각도, 끝 각도를 지정하여 원판의 일부분만 그릴 수 있습니다.
gluCylinder 함수는 쿼드릭 객체를 사용하여 원기둥을 그리는 함수입니다. 밑면과 윗면의 반지름, 높이, 세그먼트 수를 지정하여 원기둥의 모양을 조절할 수 있습니다.

Code 14-2
Input:
void UTOutputWindow::Code_14_2_Start()
{
	ResetAll();
	glfwMakeContextCurrent(GetGLFWWindow());

	GLfloat light0_position[] = { 3.f, 1.f, 1.f, 1.f };
	GLfloat light1_position[] = { -3.f, 1.f, 1.f, 1.f };
	glLightModelf(GL_LIGHT_MODEL_TWO_SIDE, 1.f);
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
	glLightfv(GL_LIGHT1, GL_POSITION, light1_position);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glEnable(GL_LIGHT1);
	glEnable(GL_DEPTH_TEST);
	glClearColor(1.f, 1.f, 1.f, 1.f);
	glEnable(GL_AUTO_NORMAL);
		
	Time_14_2 = glfwGetTime();

	MAIN_WINDOW->ExplanationContext = L"GLU NURBS 렌더러를 사용해 3차원 NURBS 곡면을 그리는 예제입니다.\n제어점의 일부를 시간에 따라 이동시켜 곡면이 변형되는 모습을 보여줍니다.";
}

void UTOutputWindow::Code_14_2()
{
	glfwMakeContextCurrent(GetGLFWWindow());

	int display_w{}, display_h{};
	glfwGetWindowSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);

	glClearColor(0.f, 0.f, 0.f, 0.f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	
	Nurbs_14_2 = gluNewNurbsRenderer();
	int s, t;
	for (s = 0; s < 4; s++) {           //x, y, z 방향으로 -3에서 +3까지
		for (t = 0; t < 4; t++) {
			ctlpointsCoordi_14_2[s][t][0] = 2.f * ((GLfloat)s - 1.5f);
			ctlpointsCoordi_14_2[s][t][2] = 2.f * ((GLfloat)t - 1.5f);
			if ((s == 1 || s == 2) && (t == 1 || t == 2))
				ctlpointsCoordi_14_2[s][t][1] = 3.f;
			else
				ctlpointsCoordi_14_2[s][t][1] = -3.f;
			for (int k = 0; k < 3; k++)
				ctlpoints_14_2[s][t][k] = weight_14_2[s][t] * ctlpointsCoordi_14_2[s][t][k];    //제어점 정보 초기화
			ctlpoints_14_2[s][t][3] = weight_14_2[s][t];
		}
	}
	
	ElapsedTime_14_2 = (GLfloat)(glfwGetTime() - Time_14_2);
	ElapsedTime_14_2 = fmod(ElapsedTime_14_2, 11.f);
	ctlpoints_14_2[1][1][1] = 1.f + std::clamp(ElapsedTime_14_2, 0.f, 11.f);
	ctlpoints_14_2[1][2][1] = 1.f + std::clamp(ElapsedTime_14_2, 0.f, 11.f);
	ctlpointsCoordi_14_2[1][1][1] = 1.f + std::clamp(ElapsedTime_14_2, 0.f, 11.f);
	ctlpointsCoordi_14_2[1][2][1] = 1.f + std::clamp(ElapsedTime_14_2, 0.f, 11.f);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-5.f, 5.f, -10.f, 10.f, -20.f, 20.f);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glTranslatef(0.f, 0.f, -15.f);
	glPushMatrix();
	glRotatef(45.f, 1.f, 0.f, 0.f);
	for (int i = 0; i < 4; i++) 
	{               
		for (int j = 0; j < 4; j++) 
		{
			glPushMatrix();
			glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, point_mat_diffuse);
			glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, point_mat_specular);
			glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, point_mat_emission);
			glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, point_mat_shininess);
			glPointSize(5.f);
			glBegin(GL_POINTS);
			glVertex3f(ctlpointsCoordi_14_2[i][j][0],
				ctlpointsCoordi_14_2[i][j][1],
				ctlpointsCoordi_14_2[i][j][2]);
			glEnd();
			glPopMatrix();
		}
	}
	glPushMatrix();
	for (int i = 0; i < 4; i++) 
	{
		for (int j = 0; j < 3; j++)
		{
			glBegin(GL_LINES);
			glVertex3f(ctlpointsCoordi_14_2[i][j][0],
				ctlpointsCoordi_14_2[i][j][1],
				ctlpointsCoordi_14_2[i][j][2]);
			glVertex3f(ctlpointsCoordi_14_2[i][j + 1][0],
				ctlpointsCoordi_14_2[i][j + 1][1],
				ctlpointsCoordi_14_2[i][j + 1][2]);
			glEnd();
		}
	}
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 4; j++) {
			glBegin(GL_LINES);
			glVertex3f(ctlpointsCoordi_14_2[i][j][0],
				ctlpointsCoordi_14_2[i][j][1],
				ctlpointsCoordi_14_2[i][j][2]);
			glVertex3f(ctlpointsCoordi_14_2[i + 1][j][0],
				ctlpointsCoordi_14_2[i + 1][j][1],
				ctlpointsCoordi_14_2[i + 1][j][2]);
			glEnd();
		}
	}

	glPopMatrix();
	glPushMatrix();
	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, surface_mat_diffuse);
	glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, surface_mat_specular);
	glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, surface_mat_emission);
	glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, surface_mat_shininess);
	gluBeginSurface(Nurbs_14_2);
	gluNurbsSurface(Nurbs_14_2, 8, knots, 8, knots, 4 * 4, 4,
		&ctlpoints_14_2[0][0][0], 4, 4, GL_MAP2_VERTEX_4);
	gluEndSurface(Nurbs_14_2);
	glPopMatrix();
	glPopMatrix();
	gluDeleteNurbsRenderer(Nurbs_14_2);
	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_14_2_End()
{
	ResetAll();

	MAIN_WINDOW->ExplanationContext = L"";
}
Description:
OpenGL에서 NURBS(Non-Uniform Rational B-Splines)는 복잡한 곡면과 곡선을 표현하는 데 사용되는 수학적 모델입니다.
NURBS는 제어점, 가중치, 매듭 벡터 등을 사용하여 유연하고 정밀한 형상을 생성할 수 있습니다.

gluNewNurbsRenderer 함수는 새로운 NURBS 렌더러 객체를 생성하고 그 객체에 대한 포인터를 반환하는 함수입니다. 이 렌더러는 NURBS 곡면과 곡선을 그리는 데 사용됩니다.
gluDeleteNurbsRenderer 함수는 생성된 NURBS 렌더러 객체를 삭제하는 함수입니다. 메모리 누수를 방지하기 위해 사용 후 반드시 호출해야 합니다.

gluBeginSurface 함수는 NURBS 곡면의 그리기를 시작하는 함수입니다. 이 함수는 NURBS 렌더러 객체를 인수로 받아 해당 렌더러에서 곡면을 그리기 위한 준비를 합니다.
gluEndSurface 함수는 NURBS 곡면의 그리기를 종료하는 함수입니다.

gluNurbsSurface 함수는 NURBS 렌더러 객체를 사용하여 NURBS 곡면을 정의하고 그리는 함수입니다.
이 함수는 매듭 벡터, 제어점 배열, 그리고 기타 매개변수를 인수로 받아 곡면의 형상을 결정합니다.

ctlpoints_14_2는 가중치가 적용된 제어점 좌표를 저장하고, ctlpointsCoordi_14_2는 실제 3D 좌표를 저장합니다.
현재 예제에서는 가운데 4개의 점은 3의 높이를, 나머지 12개의 점은 -3의 높이를 가졌습니다. 제어점의 가중치는 모두 1로 동일합니다.
시간이 흐름에 따라 3번째 줄의 가운데 2개의 점 높이는 12까지 올라갑니다.
이 배열들은 NURBS 곡면의 형태와 위치를 결정하는 데 중요한 역할을 합니다.

Code 15-2
Input:
void UTOutputWindow::Code_15_2_Start()
{
	ResetAll();
	glfwMakeContextCurrent(GetGLFWWindow());

	glEnable(GL_DEPTH_TEST);
	glClearColor(1.0, 1.0, 1.0, 1.0);
	glEnable(GL_AUTO_NORMAL);
	GLfloat light0_diffuse[] = { 0.8, 0.8, 0.2, 1.0 };
	GLfloat light0_ambient[] = { 0.8, 0.0, 0.0, 1.0 };
	GLfloat light0_position[] = { 0.8, -0.5, 2.3, 1.0 };
	glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
	glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);

	char* vertex_source, * frag_source;
	h_vertex_15_2 = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
	h_frag_15_2 = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);

	char VertexSourcePath[] = "Source/Windows/OutputCode/glsl_example.vert";
	char FragmentSourcePath[] = "Source/Windows/OutputCode/glsl_example.frag";
	vertex_source = ReadShaderSource(VertexSourcePath);
	frag_source = ReadShaderSource(FragmentSourcePath);
	const char* p_vertex_source = vertex_source;
	const char* p_frag_source = frag_source;
	glShaderSourceARB(h_vertex_15_2, 1, &p_vertex_source, NULL);
	glShaderSourceARB(h_frag_15_2, 1, &p_frag_source, NULL);
	free(vertex_source);
	free(frag_source);

	glCompileShaderARB(h_vertex_15_2);
	GLint compiled;
	glGetObjectParameterivARB(h_vertex_15_2, GL_OBJECT_COMPILE_STATUS_ARB, &compiled);

	if (!compiled)
	{
		GLint length;
		glGetObjectParameterivARB(h_vertex_15_2, GL_OBJECT_INFO_LOG_LENGTH_ARB, &length);

		if (length > 1)
		{
			char* log = (char*)malloc(length);
			glGetInfoLogARB(h_vertex_15_2, length, NULL, log);
			printf("Shader compile error:\n%s\n", log);
			free(log);
		}
	}

	glCompileShaderARB(h_frag_15_2);
	glGetObjectParameterivARB(h_frag_15_2, GL_OBJECT_COMPILE_STATUS_ARB, &compiled);

	if (!compiled)
	{
		GLint length;
		glGetObjectParameterivARB(h_frag_15_2, GL_OBJECT_INFO_LOG_LENGTH_ARB, &length);

		if (length > 1)
		{
			char* log = (char*)malloc(length);
			glGetInfoLogARB(h_frag_15_2, length, NULL, log);
			printf("Shader compile error:\n%s\n", log);
			free(log);
		}
	}
		
	h_program_15_2 = glCreateProgramObjectARB();
	glAttachObjectARB(h_program_15_2, h_vertex_15_2);
	glAttachObjectARB(h_program_15_2, h_frag_15_2);
	glLinkProgramARB(h_program_15_2);

	GLint linked;
	glGetObjectParameterivARB(h_program_15_2, GL_OBJECT_LINK_STATUS_ARB, &linked);

	if (!linked) 
	{
		GLint length;
		glGetObjectParameterivARB(h_program_15_2, GL_OBJECT_INFO_LOG_LENGTH_ARB, &length);

		if (length > 1)
		{
			char* log = (char*)malloc(length);
			glGetInfoLogARB(h_program_15_2, length, NULL, log);
			printf("Program link error:\n%s\n", log);
			free(log);
		}
	}

	glUseProgramObjectARB(h_program_15_2);

	MAIN_WINDOW->ExplanationContext = L"GLSL을 사용해 간단한 정점 및 프래그먼트 셰이더를 작성하고 적용하는 예제입니다.\n";
}

void UTOutputWindow::Code_15_2()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);

	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glColor3f(1.f, 1.f, 1.f);
	glClearColor(0.f, 0.f, 0.f, 1.f);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-1.f, 1.f, -1.f, 1.f, -1.f, 1.f);

	glBegin(GL_POLYGON);
	glVertex3f(-0.5f, -0.5f, 0.f);
	glVertex3f(0.5f, -0.5, 0.f);
	glVertex3f(0.5f, 0.5f, 0.f);
	glVertex3f(-0.5f, 0.5f, 0.f);
	glEnd();

	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_15_2_End()
{
	ResetAll();
	glfwMakeContextCurrent(GetGLFWWindow());
	if (h_program_15_2)
	{
		glDeleteObjectARB(h_program_15_2);
		h_program_15_2 = 0;
	}

	if (h_vertex_15_2)
	{
		glDeleteObjectARB(h_vertex_15_2);
		h_vertex_15_2 = 0;
	}

	if (h_frag_15_2)
	{
		glDeleteObjectARB(h_frag_15_2);
		h_frag_15_2 = 0;
	}

	MAIN_WINDOW->ExplanationContext = L"";
}

char* UTOutputWindow::ReadShaderSource(char* fileName)
{
	FILE* p_Sourcefile = NULL;
	char* contents = NULL;
	int length = 0;
	if (fileName != NULL)
	{
		int tempfile = _open(fileName, _A_RDONLY);
		length = _lseek(tempfile, 0, SEEK_END);
		_close(tempfile);

		p_Sourcefile = fopen(fileName, "rt");
		if (p_Sourcefile != NULL) 
		{
			if (0 < length) 
			{
				contents = (char*)malloc(sizeof(char) * (length + 1));
				length = fread(contents, sizeof(char), length, p_Sourcefile);
				contents[length] = '\0';
			}
			fclose(p_Sourcefile);
		}
	}
	return contents;
}
Description:
OpenGL 셰이더(Shader)는 그래픽스 파이프라인에서 실행되는 작은 프로그램으로, 주로 GPU에서 실행되어 그래픽스 렌더링을 제어합니다.
GLSL로 프로그래밍할 수 있는 지엘의 파이프라인은 버텍스 셰이더와 프래그먼트 셰이더 부분입니다.

버텍스 셰이더에서는 아래 작업들을 수행할 수 있습니다.
	1. 정점에 대한 기하 변환
	2. 법선 벹거 변환 및 정규화
	3. 텍스처 좌표 생성 및 변환
	4. 조명에 의한 정점 색 계산

프래그먼트 셰이더에서는 아래 작업들을 수행할 수 있습니다.
	1. 텍스처 영상 적용
	2. 안개 효과
	3. 컬러 블렌딩
	4. 주변 매핑
	5. 조명 및 그림자 효과

주목할 점은 버텍스 셰이더에서 텍스처 좌표나 조명에 접근이 가능하다는 것입니다. 이를 통해 버텍스 셰이더에서 계산된 값을 프래그먼트 셰이더로 전달할 수 있습니다.
또한 프래그먼트 셰이더에서는 시저 테스트, 알파 테스트, 깊이 테스트, 스텐실 테스트, 디더링 등의 파이프라인은 대체할 수 없다는 점입니다.

셰이더 코드를 OpenGL 프로그램에 통합하기 위해서는 다음과 같은 주요 함수들을 사용합니다.

glCreateShaderObjectARB 함수는 지정된 셰이더 유형(버텍스 또는 프래그먼트)에 대한 새로운 셰이더 객체를 생성하고 그 객체에 대한 핸들을 반환합니다.
glShaderSourceARB 함수는 셰이더 객체에 셰이더 소스 코드를 설정하는 함수입니다. 이 함수는 셰이더 객체 핸들, 소스 코드 문자열 배열, 그리고 각 문자열의 길이를 인수로 받습니다.
glCompileShaderARB 함수는 셰이더 객체를 컴파일하는 함수입니다. 컴파일된 셰이더는 그래픽스 파이프라인에서 사용할 수 있습니다.
glCreateProgramObjectARB 함수는 새로운 셰이더 프로그램 객체를 생성하고 그 객체에 대한 핸들을 반환하는 함수입니다.
glAttachObjectARB 함수는 셰이더 프로그램 객체에 셰이더 객체를 첨부하는 함수입니다. 이 함수는 프로그램 객체 핸들과 셰이더 객체 핸들을 인수로 받습니다.
glLinkProgramARB 함수는 첨부된 셰이더 객체들을 링크하여 실행 가능한 셰이더 프로그램을 생성하는 함수입니다.
glUseProgramObjectARB 함수는 현재 렌더링 상태에서 사용할 셰이더 프로그램을 설정하는 함수입니다. 이 함수는 셰이더 프로그램 객체 핸들을 인수로 받습니다.