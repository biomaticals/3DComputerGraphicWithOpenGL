// Copyright 2025. Team Unique Turtle ; https://github.com/biomaticals. All rights reserved.
// All contents cannot be copied, distributed, revised.


Code 6-3
Input:
void UTOutputWindow::Code_6_3_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);

	MAIN_WINDOW->ExplanationContext = L"행렬 변환의 순서에 따른 결과 차이를 확인하는 예제입니다.\n"
		"원점을 기준으로 45도 회전한 후, x축으로 0.6만큼 이동한 사각형과\n"
		"x축으로 0.6만큼 이동한 후, 45도 회전한 사각형을 비교합니다.\n\n"
		"빨간색 사각형: 먼저 45도 회전 후, x축으로 0.6만큼 이동\n"
		"초록색 사각형: 먼저 x축으로 0.6만큼 이동 후, 45도 회전";
}

void UTOutputWindow::Code_6_3()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glDisable(GL_LIGHTING);
	glBindTexture(GL_TEXTURE_2D, 0);

	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);
	glClearColor(0.f, 0.f, 0.f, 1.f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glColor3f(1.f, 1.f, 1.f);

	// 원점
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-1.f, 1.f, -1.f, 1.f, -1.f, 1.f);

	glBegin(GL_POLYGON);
	glVertex3f(0.1f, 0.1f, 0.f);
	glVertex3f(0.1f, -0.1f, 0.f);
	glVertex3f(-0.1f, -0.1f, 0.f);
	glVertex3f(-0.1f, 0.1f, 0.f);
	glEnd();

	// 45도 회전 후, x축으로 0.6만큼 이동
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glRotatef(45.f, 0.f, 0.f, 1.f);
	glTranslatef(0.6f, 0.f, 0.f);
	glColor3f(1.f, 0.f, 0.f);

	glBegin(GL_POLYGON);
	glVertex3f(0.1f, 0.1f, 0.f);
	glVertex3f(0.1f, -0.1f, 0.f);
	glVertex3f(-0.1f, -0.1f, 0.f);
	glVertex3f(-0.1f, 0.1f, 0.f);
	glEnd();

	// 먼저 x축으로 0.6만큼 이동 후, 45도 회전
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glTranslatef(0.6f, 0.f, 0.f);
	glRotatef(45.f, 0.f, 0.f, 1.f);
	glColor3f(0.f, 1.f, 0.f);

	glBegin(GL_POLYGON);
	glVertex3f(0.1f, 0.1f, 0.f);
	glVertex3f(0.1f, -0.1f, 0.f);
	glVertex3f(-0.1f, -0.1f, 0.f);
	glVertex3f(-0.1f, 0.1f, 0.f);
	glEnd();

	glFlush();
	glfwSwapBuffers(GetGLFWWindow());
}

void UTOutputWindow::Code_6_3_End()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();

	MAIN_WINDOW->ExplanationContext = L"";
}
Description:
glRoatef 함수와 glTranslatef 함수의 호출 순서에 따라 차이가 발생합니다.

glRotatef(45.f, 0.f, 0.f, 1.f); 가 먼저 호출되고 glTranslatef(0.6f, 0.f, 0.f); 가 나중에 호출되면,
변환 행렬의 곱셈 순서는 오른쪽에서 왼쪽으로 적용되므로, 실제로는 먼저 이동이 적용되고 그 다음에 회전이 적용됩니다.

Code 6-6
Input:
void UTOutputWindow::Code_6_6_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);
	glfwSetKeyCallback(GetGLFWWindow(), Code_6_6_Key);

	MAIN_WINDOW->ExplanationContext = L"행렬 스택을 활용하여 태양,지구,달의 계층적 변환을 구현합니다. glPushMatrix / glPopMatrix를 사용해 각 천체의 공전과 자전을 독립적으로 구성하면서도 부모 변환을 자연스럽게 계승합니다.\n";
	MAIN_WINDOW->DebugContext = L"1: 지구 자전 및 달 공전\n";
	MAIN_WINDOW->DebugContext += L"2: 지구 공전\n";
	MAIN_WINDOW->DebugContext += L"R: 초기화\n";
	MAIN_WINDOW->DebugContext += L"Q: 종료";
}

void UTOutputWindow::Code_6_6()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);

	glClearColor(0.f, 0.f, 0.f, 0.f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-5.f, 5.f, -5.f, 5.f, -5.f, 5.f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	// 태양
	glPushMatrix();
	glColor3f(1.f, 0.84f, 0.f);
	glBegin(GL_POLYGON);
	for (int i = 0; i < 360; i += 30)
	{
		float rad = i * 3.14159f / 180.f;
		glVertex3f(0.5f * cos(rad), 0.5f * sin(rad), 0.f);
	}
	glEnd();

	// 지구
	glRotatef(EarthOrbitAngle_6_6, 0.f, 0.f, 1.f); // 지구 공전
	glTranslatef(3.f, 0.f, 0.f);
	glRotatef(EarthRotationAngle_6_6, 0.f, 0.f, 1.f); // 지구 자전
	glPushMatrix();

	glColor3f(0.2f, 0.5f, 0.9f);
	glBegin(GL_POLYGON);
	for (int i = 0; i < 360; i += 30)
	{
		float rad = i * 3.14159f / 180.f;
		glVertex3f(0.2f * cos(rad), 0.2f * sin(rad), 0.f);
	}
	glEnd();

	// 달
	glRotatef(MoonOrbitAngle_6_6, 0.f, 0.f, 1.f); // 달 공전
	glTranslatef(0.7f, 0.f, 0.f);
	glColor3f(0.8f, 0.8f, 0.8f);
	glBegin(GL_POLYGON);
	for (int i = 0; i < 360; i += 30)
	{
		float rad = i * 3.14159f / 180.f;
		glVertex3f(0.05f * cos(rad), 0.05f * sin(rad), 0.f);
	}
	glEnd();

	glPopMatrix(); // 지구 복원
	glPopMatrix(); // 태양 복원

	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_6_6_End()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();

	MAIN_WINDOW->ExplanationContext = L"";
	MAIN_WINDOW->DebugContext = L"";
}

void UTOutputWindow::Code_6_6_Key(GLFWwindow* Window, int Key, int Scancode, int Action, int Mods)
{
	if (Action == GLFW_PRESS)
	{
		switch (Key)
		{
		case GLFW_KEY_1:
		{
			OUTPUT_WINDOW->EarthRotationAngle_6_6 += 10.f;
			OUTPUT_WINDOW->MoonOrbitAngle_6_6 += 6.f;
			break;
		}
		case GLFW_KEY_2:
		{
			OUTPUT_WINDOW->EarthOrbitAngle_6_6 += 5.f;
			break;
		}
		case GLFW_KEY_R:
		{
			OUTPUT_WINDOW->EarthOrbitAngle_6_6 = 0.f;
			OUTPUT_WINDOW->EarthRotationAngle_6_6 = 0.f;
			OUTPUT_WINDOW->MoonOrbitAngle_6_6 = 0.f;
			break;
		}
		case GLFW_KEY_Q:
		{
			exit(0);
			break;
		}
		default:
			break;
		}
	}
}
Code 6-8
Input:
void UTOutputWindow::Code_6_8_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);
	glfwMakeContextCurrent(GetGLFWWindow());

	const std::string basepath = "Resource/Object/Chaynik/";
	const std::string texbasepath = "Resource/Object/Chaynik/textures";
	const std::string objpath = basepath + "Chaynik.obj";
	RESOURCE_MANAGER->LoadObjWithMaterial(objpath, vertices_6_8, indices_6_8, materials_6_8);

	glClearColor(0.f, 0.f, 0.f, 1.f);
	GLfloat mat_diffuse[] = { 0.f, 0.4f, 0.3f, 1.f };
	GLfloat mat_specular[] = { 1.f, 1.f, 1.f, 1.f };
	GLfloat mat_ambient[] = { 0.5f, 0.4f, 0.3f, 1.f };
	GLfloat mat_shininess[] = { 15.f };
	GLfloat light_specular[] = { 1.f, 1.f, 1.f, 1.f };
	GLfloat light_diffuse[] = { 0.8f, 0.8f, 0.8f, 1.f };
	GLfloat light_ambient[] = { 0.3f, 0.3f, 0.3f, 1.f };
	GLfloat light_position[] = { -3.f, 6.f, 3.f, 0.f };

	glShadeModel(GL_SMOOTH);
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glLightfv(GL_LIGHT0, GL_POSITION, light_position);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
	glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
	glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
	glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
	glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
	glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

	MAIN_WINDOW->ExplanationContext = L"조명과 재질 속성을 사용하여 3D 모델을 렌더링하는 예제입니다.\n";
	MAIN_WINDOW->ExplanationContext += L"모델의 표면이 조명에 반응하여 현실감 있는 모습을 보여줍니다.";
}

void UTOutputWindow::Code_6_8()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glm::mat4 projection = glm::perspective(
		glm::radians(45.0f),
		(float)display_w / (float)display_h,
		0.1f,
		10000.0f
	);
	glLoadMatrixf(&projection[0][0]);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glm::mat4 view = glm::lookAt(
		glm::vec3(1.5f, 0.6f, -1.f),
		glm::vec3(0.f, 0.f, 0.f),
		glm::vec3(0.f, 1.f, 0.f)
	);
	glLoadMatrixf(&view[0][0]);

	glBegin(GL_TRIANGLES);
	for (size_t i = 0; i < indices_6_8.size(); i++)
	{
		const Vertex& v = vertices_6_8[indices_6_8[i]];
		glTexCoord2f(v.texcoord.x, v.texcoord.y);
		glNormal3f(v.normal.x, v.normal.y, v.normal.z);
		glVertex3f(v.pos.x, v.pos.y, v.pos.z);
	}
	glEnd();

	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_6_8_End()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();

	MAIN_WINDOW->ExplanationContext = L"";
	MAIN_WINDOW->DebugContext = L"";
}
Description:
암묵적으로 gl에서는 투영 행렬을 먼저 설정하고, 그 다음에 뷰 행렬을 설정합니다.

glMatrixMode(GL_MODELVIEW); // 모델뷰 행렬 모드로 전환

glLoadIdentity(); // 모델뷰 행렬을 단위 행렬로 초기화

glm::mat4 view = glm::lookAt( // 뷰 행렬 생성
	glm::vec3(1.5f, 0.6f, -1.f), // 카메라 위치
	glm::vec3(0.f, 0.f, 0.f),    // 카메라가 바라보는 지점
	glm::vec3(0.f, 1.f, 0.f)     // 카메라의 업 벡터
);

glLoadMatrixf(&view[0][0]); // 뷰 행렬을 OpenGL에 로드

Code 6-9
Input:
void UTOutputWindow::Code_6_9_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);
	glfwSetKeyCallback(GetGLFWWindow(), UTOutputWindow::Code_6_9_Key);
	glClearColor(0.f, 0.f, 0.f, 1.f);
	Gravity_6_9 = 9.8f;
	Elastic_6_9 = 0.75f;
	InitialHeight_6_9 = 30.f;
	InitialVerticalVelocity_6_9 = 0.f;
	HorizonalVelocity_6_9 = 5.f;
	Time_6_9 = glfwGetTime();

	GLfloat LightConstantAttenuation_6_9;
	GLfloat LightLinearAttenuation_6_9;
	GLfloat LightQuadraticAttenuation_6_9;

	glGetLightfv(GL_LIGHT0, GL_CONSTANT_ATTENUATION, &LightConstantAttenuation_6_9);
	glGetLightfv(GL_LIGHT0, GL_LINEAR_ATTENUATION, &LightLinearAttenuation_6_9);
	glGetLightfv(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, &LightQuadraticAttenuation_6_9);

	const std::string basepath = "Resource/Object/Soccer_ball/";
	const std::string texbasepath = "Resource/Object/Soccer_ball/textures";
	const std::string objpath = basepath + "10536_soccerball_V1_iterations-2.obj";
	RESOURCE_MANAGER->LoadObjWithMaterial(objpath, vertices_6_9, indices_6_9, materials_6_9);

	GLfloat light_specular[] = { 1.f, 1.f, 1.f, 1.f };
	GLfloat light_diffuse[] = { 0.8f, 0.8f, 0.8f, 1.f };
	GLfloat light_ambient[] = { 1.f, 1.f, 1.f, 1.f };
	GLfloat global_ambient[] = { 0.6f, 0.6f, 0.6f, 1.f };

	light_position_5_15[0] = 50.f;
	light_position_5_15[1] = 50.f;
	light_position_5_15[2] = 0.f;
	light_position_5_15[3] = 0.f;
	glShadeModel(GL_SMOOTH);
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glEnable(GL_NORMALIZE);
	glDisable(GL_COLOR_MATERIAL);

	glLightfv(GL_LIGHT0, GL_POSITION, light_position_5_15);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
	glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
	glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
	glLightModelfv(GL_LIGHT_MODEL_AMBIENT, global_ambient);
	glColor3f(1.f, 1.f, 1.f);

	MAIN_WINDOW->ExplanationContext = L"중력과 탄성 계수를 적용한 1차원 탄성 충돌 물리 모델을 사용한 바운싱 볼 시뮬레이션 예제입니다.\n";
	MAIN_WINDOW->ExplanationContext = L"사용자는 중력 가속도, 탄성 계수, 초기 높이, 초기 수직 속도를 조절하여 공의 운동을 실시간으로 관찰할 수 있습니다.\n";
}

void UTOutputWindow::Code_6_9()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(0.f, 100.f, -7.5f, 100.f, -100.f, 100.f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glLightfv(GL_LIGHT0, GL_POSITION, light_position_5_15);
	glEnable(GL_TEXTURE_2D);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
	if (!materials_6_9.empty() && materials_6_9[0].textureId != 0)
	{
		glBindTexture(GL_TEXTURE_2D, materials_6_9[0].textureId);
	}

	BoundcingBall_physics Physics{};
	Physics.Gravity = Gravity_6_9; // 중력 가속도
	Physics.Elastic = Elastic_6_9; // 탄성 계수
	Physics.IniitlaiHeight = InitialHeight_6_9; // 초기 높이
	Physics.InitialVerticalVelocity = InitialVerticalVelocity_6_9; // 초기 수직 속도
	Physics.HorizonalVelocity = HorizonalVelocity_6_9; // 수평 속도

	GLfloat currentTime = glfwGetTime();
	GLfloat deltaTime = (currentTime - Time_6_9);

	std::array<GLfloat, 2> BallPosition = GetBallState_6_9(Physics, deltaTime);

	if (BallPosition[0] >= 100.f)
	{
		Time_6_9 = currentTime;
		deltaTime = 0.f;
		BallPosition = GetBallState_6_9(Physics, deltaTime);
	}

	glTranslatef(BallPosition[0], BallPosition[1], 0.f);
	glRotatef(deltaTime * 30.f, 0.f, 0.f, -1.f);

	glBegin(GL_TRIANGLES);
	for (size_t i = 0; i < indices_6_9.size(); i++)
	{
		const Vertex& v = vertices_6_9[indices_6_9[i]];
		glTexCoord2f(v.texcoord.x, v.texcoord.y);
		glNormal3f(v.normal.x, v.normal.y, v.normal.z);
		glVertex3f(v.pos.x, v.pos.y, v.pos.z);
	}
	glEnd();

	std::wstring debugContext = L"중력가속도 증감(1/2), 탄성계수 증감(3/4), 초기 높이 증감(5/6), 초기 수직 속도 증감(7/8), 초기화(R)\n";
	debugContext += L"중력 가속도는 " + std::to_wstring(Gravity_6_9) + L", 탄성 계수는 " + std::to_wstring(Elastic_6_9) + L", 초기 높이는 " + std::to_wstring(InitialHeight_6_9) + L", 초기 수직 속도는 " + std::to_wstring(InitialVerticalVelocity_6_9);
	MAIN_WINDOW->DebugContext = debugContext;

	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_6_9_End()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();
	glfwMakeContextCurrent(GetGLFWWindow());
	glfwSetKeyCallback(GetGLFWWindow(), nullptr);
	
	Time_6_9 = 0.f;

	MAIN_WINDOW->DebugContext = L"";
	MAIN_WINDOW->ExplanationContext = L"";
}

void UTOutputWindow::Code_6_9_Key(GLFWwindow* Window, int Key, int Scancode, int Action, int Mods)
{
	if (Action != GLFW_PRESS)
		return;

	switch (Key)
	{
	case GLFW_KEY_1:
	{
		OUTPUT_WINDOW->Gravity_6_9 += 1.f;
		OUTPUT_WINDOW->Time_6_9 = glfwGetTime();
		break;
	}
	case GLFW_KEY_2:
	{
		OUTPUT_WINDOW->Gravity_6_9 = OUTPUT_WINDOW->Gravity_6_9 - 1.f > 0.f ? OUTPUT_WINDOW->Gravity_6_9 -1.f : 0.f; 
		OUTPUT_WINDOW->Time_6_9 = glfwGetTime();
		break;
	}
	case GLFW_KEY_3:
	{
		OUTPUT_WINDOW->Elastic_6_9 = OUTPUT_WINDOW->Elastic_6_9 + 0.05f > 1.f ? 1.f : OUTPUT_WINDOW->Elastic_6_9 + 0.05f;
		OUTPUT_WINDOW->Time_6_9 = glfwGetTime();
		break;
	}
	case GLFW_KEY_4:
	{
		OUTPUT_WINDOW->Elastic_6_9 = OUTPUT_WINDOW->Elastic_6_9 - 0.05f > 0.f ? OUTPUT_WINDOW->Elastic_6_9 - 0.05f : 0.f;
		OUTPUT_WINDOW->Time_6_9 = glfwGetTime();
		break;
	}
	case GLFW_KEY_5:
	{
		OUTPUT_WINDOW->InitialHeight_6_9 += 1.f;
		OUTPUT_WINDOW->Time_6_9 = glfwGetTime();
		break;
	}
	case GLFW_KEY_6:
	{
		OUTPUT_WINDOW->InitialHeight_6_9 = OUTPUT_WINDOW->InitialHeight_6_9 - 1.f > 0.f ? OUTPUT_WINDOW->InitialHeight_6_9 - 1.f : 0.f;
		OUTPUT_WINDOW->Time_6_9 = glfwGetTime();
		break;
	}
	case GLFW_KEY_7:
	{
		OUTPUT_WINDOW->InitialVerticalVelocity_6_9 += 1.f;
		OUTPUT_WINDOW->Time_6_9 = glfwGetTime();
		break;
	}
	case GLFW_KEY_8:
	{
		OUTPUT_WINDOW->InitialVerticalVelocity_6_9 -= 1.f;
		OUTPUT_WINDOW->Time_6_9 = glfwGetTime();
		break;
	}
	case GLFW_KEY_R:
	{
		OUTPUT_WINDOW->Gravity_6_9 = 9.8f;
		OUTPUT_WINDOW->Elastic_6_9 = 0.75f;
		OUTPUT_WINDOW->InitialHeight_6_9 = 30.f;
		OUTPUT_WINDOW->InitialVerticalVelocity_6_9 = 0.f;
		OUTPUT_WINDOW->Time_6_9 = glfwGetTime();
	}
	default:
	{
		break;
	}
	}
}

std::array<GLfloat, 2> 	UTOutputWindow::GetBallState_6_9(const BoundcingBall_physics Physics, const GLfloat Time)
{
	std::array<GLfloat, 2> Position{};
	Position[0] = Physics.HorizonalVelocity * Time;
	Position[1] = GetBallHeight(Physics, Time);

	return Position;
}

GLfloat UTOutputWindow::GetBallHeight(const BoundcingBall_physics Physics, const GLfloat time, const double eps /* = 1e-12 */)
{
	if (time < 0.f)
		return Physics.IniitlaiHeight;

	if (Physics.IniitlaiHeight <= 0.f && Physics.InitialVerticalVelocity <= 0.f)
		return 0.f;

	const GLfloat G = Physics.Gravity;
	const GLfloat E = Physics.Elastic;
	const GLfloat Y0 = Physics.IniitlaiHeight;
	const GLfloat V0 = Physics.InitialVerticalVelocity;

	GLfloat U0 = sqrt(V0 * V0 + 2.f * G * Y0 > 0.f ? V0 * V0 + 2.f * G * Y0 : 0.f);
	if (U0 < eps)
		return 0.f;

	GLfloat t_first_bounce = (V0 + U0) / G;
	if (time < t_first_bounce)
	{
		return Y0 + V0 * time - 0.5f * G * time * time > 0.f ? Y0 + V0 * time - 0.5f * G * time * time : 0.f;
	}

	GLfloat T = t_first_bounce;
	GLfloat U_n = E * U0;
	if (E <= 0.f)
	{
		GLfloat dt_after = 2.f * U_n / G;
		if (time < T + dt_after)
		{
			GLfloat t_in_bounce = time - T;
			return 0.f, t_in_bounce * (U_n * t_in_bounce - 0.5f * G * t_in_bounce) > 0.f ? t_in_bounce * (U_n * t_in_bounce - 0.5f * G * t_in_bounce) : 0.f;
		}
		else
		{
			return 0.f;
		}
	}

	GLint n = 1;
	while (true)
	{
		GLfloat dt_n = 2.f * U_n / G;
		if (time < T + dt_n || U_n <= eps)
		{
			GLfloat t_in_bounce = time - T;
			return t_in_bounce * (U_n - 0.5f * G * t_in_bounce) > 0.f ? t_in_bounce * (U_n - 0.5f * G * t_in_bounce) : 0.f;
		}

		T += dt_n;
		U_n *= E;
		if (U_n < eps)
			break;
		n++;
	}
	return 0.f;
}
Description:
이 예제는 중력과 탄성 계수를 고려한 바운싱 볼 시뮬레이션을 구현합니다.
사용자는 키보드 입력을 통해 중력 가속도, 탄성 계수, 초기 높이, 초기 수직 속도 등을 조절할 수 있습니다.

1. 수평 위치 계산:
수평 위치는 마찰력이 없어 일정한 수평 속도를 유지한다고 가정하여 계산합니다. 따라서, 수평 위치는 시간에 수평 속도를 곱한 값으로 계산합니다.
Position[0] = Physics.HorizonalVelocity * Time;

2. 수직 위치 계산:
수직 위치는 중력과 탄성 계수를 고려하여 계산합니다. 초기 높이와 초기 수직 속도를 기반으로, 시간에 따른 수직 위치를 계산합니다.
Position[1] = GetBallHeight(Physics, Time);

3. 바운싱 로직:
수직 위치 계산 함수(GetBallHeight)는 바운싱 로직을 포함합니다. 물체가 바닥에 닿을 때마다 속도가 탄성 계수에 의해 감소하며, 이로 인해 물체가 점점 낮게 튀어 오릅니다.

탄성 계수를 제외한 마찰에 의한 감소는 없다고 가정하고, 충돌 후의 속도는 이전 속도에 탄성 계수를 곱한 값으로 계산됩니다.
N번째 바운스 후의 속도는 다음과 같이 계산됩니다:
U_n = E * U_(n-1)
여기서 U_n은 N번째 바운스 후의 속도, E는 탄성 계수입니다.

glfw에서 얻은 시간을 바탕으로 물체의 위치를 계산하여, 매 프레임마다 물체의 위치를 업데이트하고 렌더링합니다.
위 속도에 이르는데 걸리는 시간은 다음과 같습니다:
t_first_bounce = (V0 + U0) / G;
여기서 V0는 초기 수직 속도, U0는 초기 속도, G는 중력 가속도입니다.

따라서 현재 시간에 따른 수직 위치는 다음과 같이 계산됩니다:
Y(t) = Y0 + V0 * t - 0.5 * G * t^2

Code 6-10
Input:
void UTOutputWindow::Code_6_10_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);
	glfwSetKeyCallback(GetGLFWWindow(), Code_6_10_Key);
	std::wstring MusicPath = RESOURCE_MANAGER->GetSoundPath() + L"\\funny-comedy-cartoon-background-music.mp3";
	if (std::filesystem::exists(MusicPath))
	{
		MCIERROR err = mciSendStringW((L"open \"" + MusicPath + L"\" type mpegvideo alias bgm").c_str(), NULL, 0, NULL);
		if (err != 0)
		{
			wchar_t errorText[256];
			mciGetErrorStringW(err, errorText, 256);
			std::wstring errorMessage = L"MCI Error: " + std::wstring(errorText);
			MAIN_WINDOW->DebugContext = errorMessage;
		}
		else
		{
			mciSendStringW(L"play bgm repeat", NULL, 0, NULL);
		}
	}

	glDisable(GL_TEXTURE_2D);

	glShadeModel(GL_SMOOTH);
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_NORMALIZE);
	glEnable(GL_SMOOTH);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	GLfloat ambientLight[] = { 0.3f,0.3f,0.3f,1.0f };
	GLfloat diffuseLight[] = { 0.7f,0.7f,0.7f,1.0f };
	GLfloat specular[] = { 1.0f,1.0f,1.0f,1.0f };
	GLfloat specref[] = { 1.0f,1.0f,1.0f,1.0f };
	GLfloat position[] = { 400.0,300.0,-700.0,1.0 };

	glLightfv(GL_LIGHT0, GL_AMBIENT, ambientLight);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuseLight);
	glLightfv(GL_LIGHT0, GL_SPECULAR, specular);
	glLightfv(GL_LIGHT0, GL_POSITION, position);
	glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 1.0f);
	glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, 0.0f);
	glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, 0.0f);

	glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
	glEnable(GL_COLOR_MATERIAL);
	
	GLfloat white[] = { 1.0f, 1.0f, 1.0f, 1.0f };
	glMaterialfv(GL_FRONT, GL_AMBIENT, white);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, white);
	glMaterialfv(GL_FRONT, GL_SPECULAR, white);
	glMateriali(GL_FRONT, GL_SHININESS, 128);
	
	glColor3f(1.f, 1.f, 1.f);
	glClearColor(1.0, 1.0, 1.0, 1.0);
	
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);

	Time_6_10 = glfwGetTime();
	LastTime_6_10 = Time_6_10;

	MAIN_WINDOW->DebugContext = L"1: 달리기 / 2: 잽 / 3: 로켓 펀치 / 4: 피겨 / 5: 퇴장\n";
	MAIN_WINDOW->DebugContext += L"W: 와이어프레임 드로잉 / S : 솔리드 렌더링 / P : 중지\n";
	MAIN_WINDOW->ExplanationContext = L"고정 파이프라인과 GLU 쿼드릭을 이용해 관절 기반 로봇 캐릭터를 계층적 트랜스폼으로 구성하고,\n";
	MAIN_WINDOW->ExplanationContext += L"키 입력에 따라 서로 다른 애니메이션 동작을 재생하는 시스템입니다.\n";
	MAIN_WINDOW->ExplanationContext += L"각 신체 부위는 실린더·구(Sphere)로 구성되며, glPushMatrix / glPopMatrix를 사용해 부모 - 자식 관계를 유지한 채 회전·이동 변환을 누적하여 자연스러운 관절 움직임을 구현합니다.\n";
	MAIN_WINDOW->ExplanationContext += L"애니메이션은 sin(), cos() 기반의 주기 함수로 관절 각도를 계산하여 달리기, 잽, 로켓펀치, 피겨 동작 등 다양한 모션을 표현합니다.\n";
	MAIN_WINDOW->ExplanationContext += L"또한 Wireframe / Solid 모드 전환, 음악 재생, 조명 설정 등 렌더링 환경 제어 기능도 포함되어 있습니다.\n";
}

void UTOutputWindow::Draw_Color(int i)
{
	if (i == RUN) {
		glColor3f(0.0, 1.0, 0.0);
	}
	else if (i == JAP) {
		glColor3f(1.0, 1.0, 0.0);
	}
	else if (i == ROCKET) {
		glColor3f(0.0, 1.0, 1.0);
	}
	else if (i == YUNA) {
		glColor3f(1.0, 0.0, 1.0);
	}
	else if (i == EXIT) {
		glColor3f(0.2, 0.2, 0.2);
	}
}

void UTOutputWindow::Change_Wire_Or_Solid(int i)
{ 
	if (flag_6_10 == 1)
		gluQuadricDrawStyle(cyl_6_10, GLU_LINE);
}

void UTOutputWindow::DrawL_Arm(int x, int a, int b, int c)
{
	glPushMatrix();
	Draw_Color(key_6_10);
	cyl_6_10 = gluNewQuadric();
	glRotatef(x, a, b, c);
	glRotatef(90.0, 1.0, 0.0, 0.0); // 실린더를 x축 기준으로 90도 회전(실린더 생성 시 각도 변경을 위해)
	glTranslatef(0.25, 0.0, 0.0);   // 왼쪽 어깨 시작점으로 이동
	glRotatef(15.0, 0.0, 1.0, 0.0); // 왼쪽 어깨를 y축을 기준으로 15도 회전
	Change_Wire_Or_Solid(flag_6_10);
	gluCylinder(cyl_6_10, 0.05, 0.05, 0.2, 50, 1); // 실린더를 그림
}

void UTOutputWindow::DrawL_Hand(int y, int a, int b, int c)
{
	glPushMatrix();
	Draw_Color(key_6_10);
	cyl_6_10 = gluNewQuadric();   // 실린더 객체 생성
	glTranslatef(0.0, 0.0, 0.22); // 왼손 시작점
	glRotatef(y, a, b, c);        // 파라미터 값만큼 회전
	Change_Wire_Or_Solid(flag_6_10);
	if (key_6_10 == YUNA) gluCylinder(cyl_6_10, 0.05, 0.02, 0.2, 15, 1); // 깔때기 모양 실린더를 그림
	else gluCylinder(cyl_6_10, 0.05, 0.05, 0.2, 15, 1);           // 실린더를 그림
	glPopMatrix();
}

void UTOutputWindow::DrawL_HandRocket()
{
	glPushMatrix();
	Draw_Color(key_6_10);     // 색 설정
	cyl_6_10 = gluNewQuadric(); // 실린더 객체 생성
	glTranslatef(0, 0, R_6_10); // 왼쪽 주먹 위치를 파라미터만큼 이동
	Change_Wire_Or_Solid(flag_6_10);
	gluCylinder(cyl_6_10, 0.05, 0.05, 0.2, 50, 1); // 실린더를 그림
	glPopMatrix();
}

void UTOutputWindow::DrawR_Arm(int x, int a, int b, int c)
{
	glPushMatrix();
	Draw_Color(key_6_10);     // 색 설정
	cyl_6_10 = gluNewQuadric(); // 실린더 객체 생성
	glRotatef(x, a, b, c);  // 파라미터 값만큼 회전
	glRotatef(90.0, 1.0, 0.0, 0.0); // 실린더를 x축을 기준으로 90도 회전(실린더 생성 시 각도 변경을 위해)
	glTranslatef(-0.25, 0.0, 0.0); //우측 어깨 시작점으로 이동
	glRotatef(-15.0, 0.0, 1.0, 0.0); //우측 어깨 -15도 y축기준 회전
	Change_Wire_Or_Solid(flag_6_10);
	gluCylinder(cyl_6_10, 0.05, 0.05, 0.2, 50, 1);// 실린더 그림

}

void UTOutputWindow::DrawR_Hand(int y, int a, int b, int c)
{
	glPushMatrix();
	Draw_Color(key_6_10);
	cyl_6_10 = gluNewQuadric();
	glTranslatef(0.0, 0.0, 0.22);//오른쪽 손 시작점
	glRotatef(y, a, b, c);// 파라미터값 만큼 회전
	Change_Wire_Or_Solid(flag_6_10);
	if (key_6_10 == YUNA) gluCylinder(cyl_6_10, 0.05, 0.02, 0.2, 50, 1);// 깔때기 모양 실린더 그림
	else gluCylinder(cyl_6_10, 0.05, 0.05, 0.2, 50, 1);// 실린더 그림
	glPopMatrix();
}

void UTOutputWindow::DrawR_HandRocket()
{
	glPushMatrix();
	Draw_Color(key_6_10);
	cyl_6_10 = gluNewQuadric();
	glTranslatef(0, 0, R2_6_10);//오른주먹 위치 파라미터만큼 이동
	Change_Wire_Or_Solid(flag_6_10);
	gluCylinder(cyl_6_10, 0.05, 0.05, 0.2, 50, 1);
	glPopMatrix();
}

void UTOutputWindow::DrawBody(int x, int a, int b, int c)
{
	glPushMatrix();
	Draw_Color(key_6_10);
	cyl_6_10 = gluNewQuadric();
	glRotatef(90.0, 1.0, 0.0, 0.0);//실린더 90도 x축기준 회전 (실린더 생성시 각도 변경을 위하여)
	glRotatef(x, a, b, c);
	Change_Wire_Or_Solid(flag_6_10);
	gluCylinder(cyl_6_10, 0.2, 0.2, 0.45, 50, 1);
	glPopMatrix();
}

void UTOutputWindow::DrawL_Legs(int x, int a, int b, int c)
{
	glPushMatrix();
	Draw_Color(key_6_10);
	cyl_6_10 = gluNewQuadric();
	glRotatef(90.0, 1.0, 0.0, 0.0);//실린더 90도 x축기준 회전 (실린더 생성시 각도 변경을 위하여)
	glTranslatef(0.1, 0.0, 0.42);//왼쪽 허벅지 시작점
	glRotatef(x, a, b, c);
	Change_Wire_Or_Solid(flag_6_10);
	gluCylinder(cyl_6_10, 0.05, 0.05, 0.15, 50, 1);

}

void UTOutputWindow::DrawL_foot(int y, int a, int b, int c)
{
	glPushMatrix();
	Draw_Color(key_6_10);
	cyl_6_10 = gluNewQuadric();
	glTranslatef(0.0, 0.0, 0.18);//왼쪽 종아리 시작점
	glRotatef(y, a, b, c);
	Change_Wire_Or_Solid(flag_6_10);
	if (key_6_10 == YUNA) gluCylinder(cyl_6_10, 0.05, 0.03, 0.2, 50, 1);// 깔때기 모양 실린더 그림
	else gluCylinder(cyl_6_10, 0.05, 0.05, 0.2, 50, 1);
	glPopMatrix();
}

void UTOutputWindow::DrawR_Legs(int x, int a, int b, int c)
{
	glPushMatrix();
	Draw_Color(key_6_10);
	cyl_6_10 = gluNewQuadric();//실린더 객체 생성
	glRotatef(90.0, 1.0, 0.0, 0.0);//실린더 90도 x축기준 회전 (실린더 생성시 각도 변경을 위하여)
	glTranslatef(-0.1, 0.0, 0.42);//오른쪽 허벅지 시작점
	glRotatef(x, a, b, c);
	Change_Wire_Or_Solid(flag_6_10);
	gluCylinder(cyl_6_10, 0.05, 0.05, 0.15, 50, 1);

}

void UTOutputWindow::DrawR_foot(int y, int a, int b, int c)
{
	glPushMatrix();
	Draw_Color(key_6_10);
	cyl_6_10 = gluNewQuadric();

	glTranslatef(0.0, 0.0, 0.18);//오른쪽 종아리 시작점
	glRotatef(y, a, b, c);

	Change_Wire_Or_Solid(flag_6_10);
	if (key_6_10 == YUNA) gluCylinder(cyl_6_10, 0.05, 0.03, 0.2, 15, 1);// 깔때기 모양 실린더 그림
	else gluCylinder(cyl_6_10, 0.05, 0.05, 0.2, 15, 1);
	glPopMatrix();
}

void UTOutputWindow::Drawneck()
{
	glPushMatrix();
	glColor3f(1.0, 1.0, 1.0);
	cyl_6_10 = gluNewQuadric();
	glRotatef(90.0, 1.0, 0.0, 0.0);//실린더 90도 x축기준 회전 (실린더 생성시 각도 변경을 위하여)
	glTranslatef(0.0, 0.0, -0.045); // 목 시작점
	Change_Wire_Or_Solid(flag_6_10);
	gluCylinder(cyl_6_10, 0.2, 0.2, 0.025, 100, 1);
	glPopMatrix();
}

void UTOutputWindow::DrawGround()
{
	Draw_Color(flag_6_10);//색깔 설정
	glTranslatef(0.0, -2.73, 0.0);//땅 시작점
	glRotatef(45.0, 0, 1, 0);//45도만큼 y축 방향으로 회전
	glRotatef(0.0 + time4_6_10 - 15, 0.0, 0.0, 1);// z축 기준으로 time4만큼 땅이 회전 
	Change_Wire_Or_Solid(flag_6_10);
	gluSphere(cyl_6_10, 2.5, 30, 90);
}

void UTOutputWindow::DrawHead()
{
	glTranslatef(0.0, 0.02, 0.0);//머리 시작점
	glPushMatrix();// 처음 저장 좌표 다시 저장
	cyl_6_10 = gluNewQuadric();
	Change_Wire_Or_Solid(flag_6_10);
	Draw_Color(key_6_10);//색깔 설정
	gluSphere(cyl_6_10, 0.20, 30, 10);//머리 그리기
	/*왼쪽 뿔 그리기*/
	glRotatef(90.0, 1.0, 0.0, 0.0);//실린더 90도 x축기준 회전 (실린더 생성시 각도 변경을 위하여)
	glTranslatef(-0.16, 0.0, -0.22);//왼쪽 뿔 시작점
	glRotatef(35.0, 0.0, 1.0, 0.0);//35도 y축 기준 회전
	gluCylinder(cyl_6_10, 0.005, 0.008, 0.1, 3, 1);//실린더 그림
	glPopMatrix(); // 처음 저장 좌표로 돌아 간다.
	glPushMatrix();// 처음 저장 좌표 다시 저장

	/*오른쪽 뿔 그리기*/
	glRotatef(90.0, 1.0, 0.0, 0.0);//실린더 90도 x축기준 회전 (실린더 생성시 각도 변경을 위하여)
	glTranslatef(0.16, 0.0, -0.22);//오른쪽 뿔 시작점
	glRotatef(-35.0, 0.0, 1.0, 0.0);//-35도 y축 기준 회전
	gluCylinder(cyl_6_10, 0.005, 0.008, 0.1, 3, 1);//실린더 그림
	glPopMatrix(); // 처음 저장 좌표로 돌아 간다.	
	glPushMatrix();// 처음 저장 좌표 다시 저장

	/*왼쪽 눈 그리기*/
	glTranslatef(-0.1, 0.1, 0.13);//왼쪽 눈 시작점
	glColor3f(0.0, 0.0, 0.0);// 눈 컬러 설정(흑색)
	gluSphere(cyl_6_10, 0.03, 10, 10);

	glPopMatrix(); // 처음 저장 좌표로 돌아 간다.
	glPushMatrix();// 처음 저장 좌표 다시 저장

	/*오른쪽 눈 그리기*/
	glTranslatef(0.1, 0.1, 0.13);//오른쪽 눈 시작점
	gluSphere(cyl_6_10, 0.03, 10, 10);
	glPopMatrix();// 처음 저장 좌표 다시 저장
}

void UTOutputWindow::DrawAndroid()
{
	DrawBody(0, 0, 0, 0); // 몸통 함수 호출
	Drawneck(); // 목함수 호출
	DrawHead(); // 머리 호출
	DrawR_Arm(R_Arm_x_6_10, 1, 0, 0);//우측팔뚝
	if (key_6_10 == ROCKET) DrawR_HandRocket(); // 로켓모드일때 우측로켓호출
	else DrawR_Hand(R_Arm_y_6_10, 1, 0, 0);  //우측팔호출
	DrawL_Arm(L_Arm_x_6_10, 1, 0, 0);   //좌측팔뚝
	if (key_6_10 == ROCKET) DrawL_HandRocket(); // 로켓모드일때 우측로켓호출
	else DrawL_Hand(L_Arm_y_6_10, 1, 0, 0);//좌측손호출
	DrawL_Legs(L_Leg_x_6_10, 1, 0, 0);  //좌측다리
	DrawL_foot(L_Leg_y_6_10, 1, 0, 0);  //좌측발		 
	DrawR_Legs(R_Leg_x_6_10, 1, 0, 0);  //우측다리
	DrawR_foot(R_Leg_y_6_10, 1, 0, 0);  //우측발	
}

void UTOutputWindow::Run()
{
	glLoadIdentity();//CTM 초기화
	/*
	기본적인 로봇의 움직임의 가속도는 sin() 함수를 통해 표현하였다
	또한 관절의 제한범위를 생각하여 abs() 함수를 통해 관절의 움직임을 제한하였다.
	*/
	L_Arm_x_6_10 = sin(time_6_10) * 80;           //왼팔은 80도 각도까지 움직이되 sin()함수를 사용하여 주기적인 움직임 설정
	R_Arm_x_6_10 = -L_Arm_x_6_10;               //오른팔은 왼팔반대로 80도각도까지 움직이되 sin()함수를 사용하여 주기적인 움직임 설정.
	R_Arm_y_6_10 = -abs(sin(time_6_10) * 60 + 50);  //우측팔뚝 각도조절(abs절대값을 줌으로써 팔뚝이 뒤로꺾이지 않는 한계점을 설정) 
	L_Arm_y_6_10 = -abs(-sin(time_6_10) * 60 + 50); //좌측팔뚝 각도조절(abs절대값을 줌으로써 팔뚝이 뒤로꺾이지 않는 한계점을 설정) 

	R_Leg_y_6_10 = abs(-sin(time_6_10) * 30 - 30);  //우측종아리 각도조절(abs절대값을 줌으로써 종아리가 앞으로 꺾이지 않는 한계점을 설정)
	L_Leg_y_6_10 = abs(sin(time_6_10) * 30 - 30);   //좌측종아리 각도조절(abs절대값을 줌으로써 종아리가 앞으로 꺾이지 않는 한계점을 설정)
	R_Leg_x_6_10 = sin(time_6_10) * 60;          //우측다리는 60도 각도까지 움직이되 sin()함수를 사용하여 주기적인 움직임 설정
	L_Leg_x_6_10 = -R_Leg_x_6_10;              //좌측다리는 우측다리반대로 60도 각도까지 움직이되 sin()함수를 사용하여 주기적인 움직임 설정

	////////////////display////////////////

	cyl_6_10 = gluNewQuadric(); //실린더 객체 생성
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //초기화
	glMatrixMode(GL_MODELVIEW); //모드 설정

	DrawGround();
	glLoadIdentity();

	/*
	로봇이 달리면서 앞,뒤로 뒤뚱거리고 몸이 틀어지는 것을 표현
	*/
	glRotatef(-230.0, 0, 1, 0);//y축으로 기울임
	glRotatef(abs(sin(time_6_10) * 16), 1, 0, 0);//x축으로 16도 까지 각도틀어짐(abs절대값을 줌으로써 몸체가 뒤로 꺾이지 않는 한계점을 설정)
	glRotatef(sin(time_6_10) * 16, 0, 1, 0); //y축으로 16도 까지 각도틀어짐, sin()함수를 사용하여 주기적인 움직임 설정

	/*
	로봇이 달리면서 상,하로 움직이는 것을 표현
	*/
	float i = 0;
	i = abs(sin(time_6_10) * 0.08); //i변수값 설정
	glPushMatrix();
	glTranslatef(0.0, i, 0); //변수 i만큼 로봇의 몸체가 Y축기준으로 움직임.

	glTranslatef(0.0, 0.5, 0.0);//최초 로봇의 위치 
	DrawAndroid();
	glfwSwapBuffers(OUTPUT_WINDOW->GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Jap()
{
	glLoadIdentity();
	L_Arm_x_6_10 = (-40) + sin(time2_6_10) * 60;//왼쪽 어깨의 각도시작은 -40상태에서 sin()함수를 사용하여 주기적인 움직임 설정
	R_Arm_x_6_10 = (-80) - L_Arm_x_6_10;      //우측 어깨의 각도시작은 -80상태에서 왼쪽어깨 움직임의 반대로 설정
	R_Arm_y_6_10 = -abs(cos(time2_6_10) * 80);  //우측팔뚝 각도조절(팔을 뻗는 움직임표현을위하여 어깨의 sin()함수와 반대인 cos()함수 사용)
	L_Arm_y_6_10 = -abs(-cos(time2_6_10) * 80); //좌측팔뚝 각도조절(팔을 뻗는 움직임표현을위하여 어깨의 sin()함수와 반대인 cos()함수 사용)

	R_Leg_y_6_10 = abs(-sin(time2_6_10) * 30 - 20);  //우측종아리 각도조절(abs절대값을 줌으로써 종아리가 앞으로 꺾이지 않는 한계점을 설정)
	L_Leg_y_6_10 = abs(sin(time2_6_10) * 30 - 20);   //좌측종아리 각도조절(abs절대값을 줌으로써 종아리가 앞으로 꺾이지 않는 한계점을 설정)
	R_Leg_x_6_10 = sin(time2_6_10) * 30;          //우측다리는 30도 각도까지 움직이되 sin()함수를 사용하여 주기적인 움직임 설정
	L_Leg_x_6_10 = -R_Leg_x_6_10;              //좌측다리는 우측다리반대로 30도 각도까지 움직이되 sin()함수를 사용하여 주기적인 움직임 설정

	////////////////display////////////////
	cyl_6_10 = gluNewQuadric();
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glMatrixMode(GL_MODELVIEW);

	DrawGround();
	glLoadIdentity();

	glRotatef(-230.0, 0, 1, 0);

	glRotatef(sin(time2_6_10) * 10, 0, 0, 1);//로봇의 좌,우 반동 표현(좌우로 10도 만큼 주기적인 움직임 설정)

	float j = 0;
	j = abs(sin(time2_6_10) * 0.085);
	glPushMatrix();
	glTranslatef(0.0, j, 0);
	glTranslatef(0.0, 0.5, 0.0);
	DrawAndroid();
	glfwSwapBuffers(OUTPUT_WINDOW->GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::ex()
{
	glLoadIdentity();
	L_Arm_x_6_10 = (-40) + sin(time6_6_10) * 60;//왼쪽 어깨의 각도시작은 -40상태에서 sin()함수를 사용하여 주기적인 움직임 설정
	R_Arm_x_6_10 = (-80) - L_Arm_x_6_10;      //우측 어깨의 각도시작은 -80상태에서 왼쪽어깨 움직임의 반대로 설정
	R_Arm_y_6_10 = -abs(cos(time6_6_10) * 10);  //우측팔뚝 각도조절(팔을 뻗는 움직임표현을위하여 어깨의 sin()함수와 반대인 cos()함수 사용)
	L_Arm_y_6_10 = -abs(-cos(time6_6_10) * 10);  //좌측팔뚝 각도조절(팔을 뻗는 움직임표현을위하여 어깨의 sin()함수와 반대인 cos()함수 사용)

	R_Leg_y_6_10 = abs(-sin(time6_6_10) * 30 - 30);  //우측종아리 각도조절(abs절대값을 줌으로써 종아리가 앞으로 꺾이지 않는 한계점을 설정)
	L_Leg_y_6_10 = abs(sin(time6_6_10) * 30 - 30);  //좌측종아리 각도조절(abs절대값을 줌으로써 종아리가 앞으로 꺾이지 않는 한계점을 설정)
	R_Leg_x_6_10 = sin(time6_6_10) * 60;           //우측다리는 60도 각도까지 움직이되 sin()함수를 사용하여 주기적인 움직임 설정
	L_Leg_x_6_10 = -R_Leg_x_6_10;              //좌측다리는 우측다리반대로 60도 각도까지 움직이되 sin()함수를 사용하여 주기적인 움직임 설정

	////////////////display////////////////
	cyl_6_10 = gluNewQuadric();
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glMatrixMode(GL_MODELVIEW);

	glLoadIdentity();
	glRotatef(-180, 0, 1, 0);
	glRotatef(time6_6_10, 0, 0, 1);

	glScalef(0.4 / (sin(time3_6_10)), 0.4 / (sin(time3_6_10)), 0.4 / (sin(time3_6_10))); //0.4의 크기에서 sin()를 통한 크기조절을 주기적으로 가함에따라 

	glPushMatrix();
	glTranslatef(0.0, 0.5, 0.0);
	DrawAndroid();
	glfwSwapBuffers(OUTPUT_WINDOW->GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Show()
{
	glLoadIdentity();

	L_Arm_x_6_10 = (-40) + sin(time2_6_10) * 60;//왼쪽 어깨의 각도시작은 -40상태에서 sin()함수를 사용하여 주기적인 움직임 설정
	R_Arm_x_6_10 = (-80) - L_Arm_x_6_10;       //우측 어깨의 각도시작은 -80상태에서 왼쪽어깨 움직임의 반대로 설정
	R_Arm_y_6_10 = -abs(cos(time2_6_10) * 10);  //우측팔뚝 각도조절(팔을 뻗는 움직임표현을위하여 어깨의 sin()함수와 반대인 cos()함수 사용)
	L_Arm_y_6_10 = -abs(-cos(time2_6_10) * 10); //좌측팔뚝 각도조절(팔을 뻗는 움직임표현을위하여 어깨의 sin()함수와 반대인 cos()함수 사용)

	R_Leg_y_6_10 = abs(-sin(time2_6_10) * 30 - 30); //우측종아리 각도조절(abs절대값을 줌으로써 종아리가 앞으로 꺾이지 않는 한계점을 설정)
	L_Leg_y_6_10 = abs(sin(time2_6_10) * 30 - 30);  //좌측종아리 각도조절(abs절대값을 줌으로써 종아리가 앞으로 꺾이지 않는 한계점을 설정)
	R_Leg_x_6_10 = sin(time2_6_10) * 60;          //우측다리는 60도 각도까지 움직이되 sin()함수를 사용하여 주기적인 움직임 설정
	L_Leg_x_6_10 = -R_Leg_x_6_10;             //좌측다리는 우측다리반대로 60도 각도까지 움직이되 sin()함수를 사용하여 주기적인 움직임 설정

	////////////////display////////////////

	cyl_6_10 = gluNewQuadric();
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glMatrixMode(GL_MODELVIEW);

	DrawGround();
	glLoadIdentity();
	glRotatef(-230.0, 0, 1, 0);

	glRotatef(sin(time2_6_10) * 7, 0, 0, 1); //z축기준으로 7도 까지 각도틀어짐 (sin()함수를 사용하여 주기적인 움직임 설정)
	glRotatef(sin(time2_6_10) * 7, 0, 1, 0); //y축으로 7도 까지 각도틀어짐 (sin()함수를 사용하여 주기적인 움직임 설정)

	glTranslatef(0.0, 0.18, 0.0);
	glRotatef(80, 1, 0, 0);

	glTranslatef(0.0, 0.5, 0.0);

	glPushMatrix();

	DrawBody(0, 0, 0, 0);

	glPopMatrix();
	glPushMatrix();

	Drawneck();

	glPopMatrix();
	glPushMatrix();

	glRotatef(-75, 1, 0, 0); //x축기준으로 회전(머리를 위쪽으로 돌리기)
	glTranslatef(0.0, -0.02, 0.0); //y축으로 이동 (머리 시작점)

	DrawHead();

	glPopMatrix();
	glPushMatrix();

	DrawR_Arm((R_Arm_y_6_10 + 30), 1, 0, 0);  //우측팔호출
	DrawR_Hand(-(R_Arm_y_6_10 - 15), 1, 0, 0); //우측팔뚝

	glPopMatrix();
	glPushMatrix();

	glTranslatef(0.0, -0.16, -0.04);//y축,z축으로 이동(좌측팔 시작점)
	glRotatef(40, 0, 0, 1);     //z축 기준으로 회전

	DrawL_Arm((L_Arm_y_6_10 + 30), 1, 0, 0);   //좌측팔호출	
	DrawL_Hand(-(L_Arm_y_6_10 - 15), 1, 0, 0);  //좌측팔뚝

	glPopMatrix();
	glPushMatrix();

	glTranslatef(0.0, -0.45, -0.25);//y축,z축으로 이동(좌측다리 시작점)
	glRotatef(-90, 1, 0, 0);  //x축 기준으로 회전

	DrawL_Legs(-30, 1, 0, 0);  //좌측다리
	DrawL_foot(10, 1, 0, 0);  //좌측종아리		 

	glPopMatrix();
	glPushMatrix();

	glTranslatef(0.0, -0.5, -0.5);//y축,z축으로 이동(우측다리 시작점)
	glRotatef(-90, 1, 0, 0); //x축 기준으로 회전

	DrawR_Legs(160, 1, 0, 0);
	DrawR_foot(R_Leg_y_6_10, 1, 0, 0);

	glPopMatrix();

	glfwSwapBuffers(OUTPUT_WINDOW->GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Rocket()
{
	glLoadIdentity();

	/*90도 각도로 팔을 앞으로 내민다*/
	L_Arm_x_6_10 = -90;
	R_Arm_x_6_10 = -90;

	R_6_10 = 2 * abs(-sin(time2_6_10) * 0.2 - 0.2) + 0.2;//우측 로켓 움직임 설정
	//abs절대값으로 로켓이 앞쪽으로 나가게 설정.
	//+0.2를 통해 로켓의 처음위치 조절. 2*를 통해 로켓이 나가는 거리조절.
	//sin()함수를 통해 주기적인 움직임 설정.

	R2_6_10 = 2 * abs(sin(time2_6_10) * 0.2 - 0.2) + 0.2;//좌측 로켓 움직임 설정 
	//abs절대값으로 로켓이 앞쪽으로 나가게 설정.
	//+0.2를 통해 로켓의 처음위치 조절. 2*를 통해 로켓이 나가는 거리조절.
	//sin()함수를 통해 주기적인 움직임 설정.

	R_Leg_y_6_10 = abs(-sin(time2_6_10) * 30 - 30);  //우측종아리 각도조절(abs절대값을 줌으로써 종아리가 앞으로 꺾이지 않는 한계점을 설정)
	L_Leg_y_6_10 = abs(sin(time2_6_10) * 30 - 30);   //좌측종아리 각도조절(abs절대값을 줌으로써 종아리가 앞으로 꺾이지 않는 한계점을 설정)
	R_Leg_x_6_10 = sin(time2_6_10) * 60;          //우측다리는 60도 각도까지 움직이되 sin()함수를 사용하여 주기적인 움직임 설정
	L_Leg_x_6_10 = -R_Leg_x_6_10;              //좌측다리는 우측다리반대로 60도 각도까지 움직이되 sin()함수를 사용하여 주기적인 움직임 설정

	////////////////display////////////////
	cyl_6_10 = gluNewQuadric(); //실린더 객체 생성
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //초기화
	glMatrixMode(GL_MODELVIEW); //모드 설정

	DrawGround();

	glLoadIdentity();
	glPushMatrix();
	glRotatef(-230.0, 0, 1, 0);

	/*
	로봇이 로켓을 쏠 때 상,하,좌,우로 몸을 트는 모습을 설정
	*/
	glRotatef(-abs(sin(time2_6_10) * 8), 1, 0, 0); //x축으로 8도 까지 각도틀어짐(abs절대값을 줌으로써 몸체가 뒤로 꺾이지 않는 한계점을 설정)
	glRotatef(sin(time2_6_10) * 7, 0, 0, 1);       //z축으로 7도 까지 각도틀어짐, sin()함수를 사용하여 주기적인 움직임 설정

	/*
	로봇이 로켓을 날리며 몸을 튕기는 모습을 표현
	*/
	float i = 0;
	i = abs(sin(time2_6_10) * 0.08); //i값 설정 
	glTranslatef(0.0, i, 0); //변수 i만큼 이동
	glTranslatef(0.0, 0.5, 0.0);//최초 위치 
	DrawAndroid();
	glfwSwapBuffers(OUTPUT_WINDOW->GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_6_10()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	GLfloat CurrentTime = glfwGetTime();
	GLfloat DeltaTime = CurrentTime - LastTime_6_10;

	time_6_10 = time_6_10 + 2.5f * DeltaTime;
	time2_6_10 = time2_6_10 + 12.5f * DeltaTime;
	time3_6_10 = time3_6_10 + 0.25f * DeltaTime;
	time4_6_10 = time4_6_10 + 25.f * DeltaTime;

	LastTime_6_10 = CurrentTime;

	if (key_6_10 == RUN)
	{
		Run();
		glPopMatrix();
	}
	else if (key_6_10 == JAP)
	{
		Jap();
		glPopMatrix();
	}
	else if (key_6_10 == ROCKET)
	{
		Rocket();
		glPopMatrix();
	}
	else if (key_6_10 == YUNA)
	{
		Show();
		glPopMatrix();
	}
	else if (key_6_10 == EXIT)
	{
		ex();
		glPopMatrix();
	}
	glFlush();
}

void UTOutputWindow::Code_6_10_End()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();
	glfwSetKeyCallback(GetGLFWWindow(), nullptr);
	mciSendStringW(L"close bgm", NULL, 0, NULL);

	Time_6_10 = glfwGetTime();
	LastTime_6_10 = Time_6_10;


	MAIN_WINDOW->DebugContext = L"";
	MAIN_WINDOW->ExplanationContext = L"";
}

void UTOutputWindow::Code_6_10_Key(GLFWwindow* Window, int Key, int Scancode, int Action, int Mods)
{
	if (Action == GLFW_PRESS)
	{
		switch (Key)
		{
		case GLFW_KEY_1:
			OUTPUT_WINDOW->key_6_10 = 1;
			break;
		case GLFW_KEY_2:
			OUTPUT_WINDOW->key_6_10 = 2;
			break;
		case GLFW_KEY_3:
			OUTPUT_WINDOW->key_6_10 = 3;
			break;
		case GLFW_KEY_4:
			OUTPUT_WINDOW->key_6_10 = 4;
			break;
		case GLFW_KEY_5:
			OUTPUT_WINDOW->key_6_10 = 5;
			break;
		case GLFW_KEY_W:
			OUTPUT_WINDOW->flag_6_10 = 1;
			break;
		case GLFW_KEY_S:
			OUTPUT_WINDOW->flag_6_10 = 0;
			break;
		case GLFW_KEY_P:
			OUTPUT_WINDOW->key_6_10 = 6;
			break;
		}
	}
}
Description:
이 프로젝트는 OpenGL을 이용하여 안드로이드 로봇이 달리고, 잽을 날리고, 로켓을 쏘고, 김연아 선수의 모션을 취하고, 퇴장하는 모습을 구현한 것입니다.

Code 7-1
Input:
void UTOutputWindow::Code_7_1_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);
	glfwMakeContextCurrent(GetGLFWWindow());

	const std::string basepath = "Resource/Object/Chaynik/";
	const std::string texbasepath = "Resource/Object/Chaynik/textures";
	const std::string objpath = basepath + "Chaynik.obj";
	RESOURCE_MANAGER->LoadObjWithMaterial(objpath, vertices_7_1, indices_7_1, materials_7_1);

	glClearColor(0.f, 0.f, 0.f, 1.f);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-0.5, 0.5, -0.5, 0.5, -0.5, 5.0);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	GLfloat mat_diffuse[] = { 0.f, 0.4f, 0.3f, 1.f };
	GLfloat mat_specular[] = { 1.f, 1.f, 1.f, 1.f };
	GLfloat mat_ambient[] = { 0.5f, 0.4f, 0.3f, 1.f };
	GLfloat mat_shininess[] = { 15.f };
	GLfloat light_specular[] = { 1.f, 1.f, 1.f, 1.f };
	GLfloat light_diffuse[] = { 0.8f, 0.8f, 0.8f, 1.f };
	GLfloat light_ambient[] = { 0.3f, 0.3f, 0.3f, 1.f };
	GLfloat light_position[] = { -3.f, 6.f, 3.f, 0.f };

	glShadeModel(GL_SMOOTH);
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glLightfv(GL_LIGHT0, GL_POSITION, light_position);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
	glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
	glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
	glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
	glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
	glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

	
	MAIN_WINDOW->ExplanationContext = L"하나의 3D 장면을 네 개의 서로 다른 카메라 시점에서 동시에 렌더링하는 예제입니다.\n";
	MAIN_WINDOW->DebugContext = L"좌하단: 정면 / 우하단 : 우측면 / 좌상단 : 평면 (이상 정투영)\n";
	MAIN_WINDOW->DebugContext += L"우상단: 원근투영으로 대각선에서 바라본 씬\n";
}

void UTOutputWindow::Code_7_1()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glColor3f(1.0, 1.0, 1.0);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-0.5, 0.5, -0.5, 0.5, -0.5, 5.0);

	glViewport(0, 0, display_w / 2, display_h / 2);
	glPushMatrix();
		gluLookAt(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
		Code_7_1_DrawScene();
		glPopMatrix();
	glPopMatrix();
	
 	glViewport(display_w / 2, 0, display_w / 2, display_h / 2);
 	glPushMatrix();
 		gluLookAt(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
 		Code_7_1_DrawScene();
 	glPopMatrix();
 	
 	glViewport(0, display_h / 2, display_w / 2, display_h / 2);
 	glPushMatrix();
 		gluLookAt(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0);
 		Code_7_1_DrawScene();
 	glPopMatrix();
 	
 	glViewport(display_w / 2, display_h / 2, display_w / 2, display_h / 2);
 	glMatrixMode(GL_PROJECTION);
 	glPushMatrix();
 		glLoadIdentity();
 		gluPerspective(30, 1.0, 0.001, 10.0);
 		glMatrixMode(GL_MODELVIEW);
 		glPushMatrix();
 			gluLookAt(1.0, 0.5, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
 			Code_7_1_DrawScene();
 		glPopMatrix();
 		glMatrixMode(GL_PROJECTION);
 	glPopMatrix();

	glfwSwapBuffers(GetGLFWWindow());
}

void UTOutputWindow::Code_7_1_End()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();

	MAIN_WINDOW->ExplanationContext = L"";
	MAIN_WINDOW->DebugContext = L"";
}

void UTOutputWindow::Code_7_1_DrawScene()
{
	glColor3f(0.1, 0.1, 0.1);
	glPushMatrix();
		glBegin(GL_QUADS);
			glVertex3f(2.0, 0.0, 2.0);
			glVertex3f(2.0, 0.0, -2.0);
			glVertex3f(-2.0, 0.0, -2.0);
			glVertex3f(-2.0, 0.0, 2.0);
		glEnd();
	glPopMatrix();

	glPushMatrix();
		glBegin(GL_TRIANGLES);
		for(GLint i = 0; i < indices_7_1.size(); i++)
		{
			const Vertex& v = vertices_7_1[indices_7_1[i]];
			glTexCoord2f(v.texcoord.x, v.texcoord.y);
			glNormal3f(v.normal.x, v.normal.y, v.normal.z);
			glVertex3f(v.pos.x, v.pos.y, v.pos.z);
		}
		glEnd();
	glPopMatrix();
}
Description:
gluPerspective 함수는 OpenGL에서 원근 투영을 설정하는 데 사용되는 함수입니다. 이 함수는 시야각, 종횡비, 근평면 및 원평면 거리를 지정하여 3D 장면이 2D 화면에 어떻게 투영될지를 정의합니다. 주요 매개변수는 다음과 같습니다:
- fovy: 시야각 (Field of View in Y direction)으로, 카메라의 수직 시야 범위를 도(degree) 단위로 지정합니다.
- aspect: 종횡비 (Aspect Ratio)로, 화면의 너비와 높이의 비율을 나타냅니다. 일반적으로 화면의 너비를 높이로 나눈 값입니다.
- zNear: 근평면 (Near Clipping Plane) 거리로, 카메라에서 가장 가까운 렌더링 가능한 거리를 지정합니다. 이 거리보다 가까운 객체는 렌더링되지 않습니다.
- zFar: 원평면 (Far Clipping Plane) 거리로, 카메라에서 가장 먼 렌더링 가능한 거리를 지정합니다. 이 거리보다 먼 객체는 렌더링되지 않습니다.

gluLookAt 함수는 OpenGL에서 카메라의 위치와 방향을 설정하는 데 사용되는 함수입니다. 이 함수는 카메라의 위치, 바라보는 지점, 그리고 카메라의 상향 벡터를 지정하여 3D 장면에서 카메라의 시점을 정의합니다. 주요 매개변수는 다음과 같습니다:
- eyeX, eyeY, eyeZ: 카메라의 위치를 나타내는 좌표입니다.
- centerX, centerY, centerZ: 카메라가 바라보는 지점의 좌표입니다.
- upX, upY, upZ: 카메라의 상향 벡터를 나타내는 값으로, 일반적으로 (0, 1, 0)으로 설정하여 카메라가 위쪽을 향하도록 합니다.

Code 8-3
Input:
void UTOutputWindow::Code_8_3_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);

	const std::string basepath = "Resource/Object/Chaynik/";
	const std::string texbasepath = "Resource/Object/Chaynik/textures";
	const std::string objpath = basepath + "Chaynik.obj";
	RESOURCE_MANAGER->LoadObjWithMaterial(objpath, vertices_8_3, indices_8_3, materials_8_3);

	glClearColor(0.f, 0.f, 0.f, 1.f);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	glOrtho(-0.5, 0.5, -0.5, 0.5, -0.5, 5.0);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	GLfloat mat_diffuse[] = { 0.f, 0.4f, 0.3f, 1.f };
	GLfloat mat_specular[] = { 1.f, 1.f, 1.f, 1.f };
	GLfloat mat_ambient[] = { 0.5f, 0.4f, 0.3f, 1.f };
	GLfloat mat_shininess[] = { 15.f };
	GLfloat light_specular[] = { 1.f, 1.f, 1.f, 1.f };
	GLfloat light_diffuse[] = { 0.8f, 0.8f, 0.8f, 1.f };
	GLfloat light_ambient[] = { 0.3f, 0.3f, 0.3f, 1.f };
	GLfloat light_position[] = { -3.f, 6.f, 3.f, 0.f };

	glShadeModel(GL_SMOOTH);
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glLightfv(GL_LIGHT0, GL_POSITION, light_position);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
	glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
	glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
	glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
	glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
	glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

	glFlush();

	MAIN_WINDOW->ExplanationContext = L"후면 제거 및 깊이버퍼 테스트로 인한 은면의 효과를 비교하는 예제입니다.\n";
	MAIN_WINDOW->DebugContext = L"좌하단: 후면, 은면 모두 존재\n";
	MAIN_WINDOW->DebugContext += L"우하단 : 후면 제거\n";
	MAIN_WINDOW->DebugContext += L"좌상단 : 후면, 은면 제거\n";
	MAIN_WINDOW->DebugContext += L"우상단 : 은면 제거\n";
}

void UTOutputWindow::Code_8_3()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glColor3f(1.0, 1.0, 1.0);

	// 좌하단 - 후면, 은면 모두 존재
	glDisable(GL_CULL_FACE);
	glDisable(GL_DEPTH_TEST);
	glViewport(0, 0, display_w / 2, display_h / 2);
	glPushMatrix();
	gluLookAt(1.0, 0.5, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
	glBegin(GL_TRIANGLES);
	for (size_t i = 0; i < indices_8_3.size(); i++)
	{
		const Vertex& v = vertices_8_3[indices_8_3[i]];
		glTexCoord2f(v.texcoord.x, v.texcoord.y);
		glNormal3f(v.normal.x, v.normal.y, v.normal.z);
		glVertex3f(v.pos.x, v.pos.y, v.pos.z);
	}
	glEnd();
	glPopMatrix();
	glFlush();

	// 우하단 - 후면 제거
	glClear(GL_DEPTH_BUFFER_BIT);
	glFrontFace(GL_CCW);
	glCullFace(GL_BACK);
	glEnable(GL_CULL_FACE);
	glDisable(GL_DEPTH_TEST);
	glViewport(display_w / 2, 0, display_w / 2, display_h / 2);
	glPushMatrix();
	gluLookAt(1.0, 0.5, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
	glBegin(GL_TRIANGLES);
	for (size_t i = 0; i < indices_8_3.size(); i++)
	{
		const Vertex& v = vertices_8_3[indices_8_3[i]];
		glTexCoord2f(v.texcoord.x, v.texcoord.y);
		glNormal3f(v.normal.x, v.normal.y, v.normal.z);
		glVertex3f(v.pos.x, v.pos.y, v.pos.z);
	}
	glEnd();
	glPopMatrix();

	// 좌상단, 후면, 은면 제거
	glClear(GL_DEPTH_BUFFER_BIT);
	glFrontFace(GL_CCW);
	glCullFace(GL_BACK);
	glEnable(GL_CULL_FACE);
	glEnable(GL_DEPTH_TEST);
	glViewport(0, display_h / 2, display_w / 2, display_h / 2);
	glPushMatrix();
	gluLookAt(1.0, 0.5, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
	glBegin(GL_TRIANGLES);
	for (size_t i = 0; i < indices_8_3.size(); i++)
	{
		const Vertex& v = vertices_8_3[indices_8_3[i]];
		glTexCoord2f(v.texcoord.x, v.texcoord.y);
		glNormal3f(v.normal.x, v.normal.y, v.normal.z);
		glVertex3f(v.pos.x, v.pos.y, v.pos.z);
	}
	glEnd();
	glPopMatrix();

	// 은면 제거
	glClear(GL_DEPTH_BUFFER_BIT);
	glFrontFace(GL_CCW);
	glCullFace(GL_BACK);
	glDisable(GL_CULL_FACE);
	glEnable(GL_DEPTH_TEST);
	glViewport(display_w / 2, display_h / 2, display_w / 2, display_h / 2);
	glPushMatrix();
	gluLookAt(1.0, 0.5, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
	glBegin(GL_TRIANGLES);
	for (size_t i = 0; i < indices_8_3.size(); i++)
	{
		const Vertex& v = vertices_8_3[indices_8_3[i]];
		glTexCoord2f(v.texcoord.x, v.texcoord.y);
		glNormal3f(v.normal.x, v.normal.y, v.normal.z);
		glVertex3f(v.pos.x, v.pos.y, v.pos.z);
	}
	glEnd();
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_8_3_End()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();

	MAIN_WINDOW->ExplanationContext = L"";
	MAIN_WINDOW->DebugContext = L"";
}
Description:
glFrontFace 함수는 OpenGL에서 폴리곤의 앞면과 뒷면을 정의하는 데 사용됩니다. 이 함수는 폴리곤의 정점이 시계방향(CW)인지 반시계방향(CCW)인지에 따라 앞면을 결정합니다. 기본값은 반시계방향(CCW)입니다. 즉, 정점이 반시계방향으로 정의된 폴리곤이 앞면으로 간주됩니다.
glCullFace 함수는 OpenGL에서 폴리곤의 어느 면을 제거할지 지정하는 데 사용됩니다. 이 함수는 glFrontFace 함수와 함께 사용되어, 앞면과 뒷면 중 어느 면을 렌더링하지 않을지 결정합니다.
glEnable(GL_CULL_FACE) 함수는 은면 제거를 활성화합니다. 이 기능이 활성화되면, glCullFace 함수에서 지정한 면이 렌더링되지 않습니다.

glEnable(GL_DEPTH_TEST) 함수는 깊이 테스트를 활성화합니다. 깊이 테스트는 3D 장면에서 객체들이 서로 겹칠 때, 카메라에 더 가까운 객체가 더 먼 객체를 가리도록 하는 기능입니다. 깊이 테스트가 활성화되면, OpenGL은 각 픽셀의 깊이 값을 비교하여 어떤 픽셀이 화면에 그려질지 결정합니다. 이를 통해 올바른 시각적 표현을 유지할 수 있습니다.

Code 8-6
Input:
void UTOutputWindow::Code_8_6_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);
	glOrtho(-1.f, 1.f, -1.f, 1.f, -1.f, 1.f);

	MAIN_WINDOW->ExplanationContext = L"배경과 물체를 그려내기 위해 깊이 버퍼와 색깔 버퍼를 분리해서 처리하는 방법을 보여줍니다.\n";
}

void UTOutputWindow::Code_8_6()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	// 깊이 테스트는 켜지만 버퍼에는 기록하지 않음
 	glEnable(GL_DEPTH_TEST);
	glDepthMask(GL_FALSE);
	glColor3f(0.62f, 0.45f, 0.35f);
	glBegin(GL_POLYGON);
	glVertex3f(-0.9f, -0.9f, 0.1f);
	glVertex3f(0.9f, -0.9f, 0.1f);
	glVertex3f(0.9f, 0.9f, 0.1f);
	glVertex3f(-0.9f, 0.9f, 0.1f);
	glEnd();
	glColor3f(0.92f, 0.63f, 0.45f);
	glBegin(GL_TRIANGLES);
	glVertex3f(-0.5f, -0.5f, 0.5f);
	glVertex3f(0.5f, -0.5f, 0.5f);
	glVertex3f(0.f, 0.5f, 0.5f);
	glEnd();

	// 깊이 버퍼에 기록은 하지만 색깔 버퍼에는 기록하지 않음
	glDepthMask(GL_TRUE);
	glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
	glColor3f(0.f, 1.f, 0.f);
	glBegin(GL_POLYGON);
	glVertex3f(-0.9f, -0.9f, 0.1f);
	glVertex3f(0.9f, -0.9f, 0.1f);
	glVertex3f(0.9f, 0.9f, 0.1f);
	glVertex3f(-0.9f, 0.9f, 0.1f);
	glEnd();
	glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);

	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_8_6_End()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();

	MAIN_WINDOW->ExplanationContext = L"";
}
Description:
+Z 방향에서 0.1f 위치에 사각형 폴리곤을 그리고, +Z 방향에서 0.5f 위치에 삼각형 폴리곤이 있습니다.
이 때, 사각형 폴리곤이 배경화면이 되어, 삼각형 폴리곤이 어디에 존재하든 사각형 폴리곤 위에 그려지게 하고자 합니다.
이 때, 의사 코드는 아래와 같습니다.
1. 깊이 테스트 활성화, 깊이 버퍼 비활성화
2. 사각형 폴리곤 그리기
3. 삼각형 폴리곤 그리기
4. 깊이 버퍼 활성화, 색상 버퍼 비활성화
5. 사각형 폴리곤 그리기

이렇게 하면 깊이 버퍼에는 사각형 폴리곤의 깊이만 저장됩니다.
삼각형 폴리곤은 깊이 버퍼에 영향을 주지 않으므로, 삼각형 폴리곤이 어디에 존재하든 사각형 폴리곤 위에 그려지게 됩니다.

투명한 오브젝트를 그리거나, UI / HUD / 2D 오버레이드를 그릴 때 위와 같은 테크닉을 사용합니다.

Code 9-10
Input:
void UTOutputWindow::Code_9_10_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);

	MAIN_WINDOW->ExplanationContext = L"지엘에서 점, 선을 그리고 선분과 다각형을 보간에 의해 채우는 것을 보여줍니다.\n";
}

void UTOutputWindow::Code_9_10()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glOrtho(-1.f, 1.f, -1.f, 1.f, -1.f, 1.f);

	// 좌측 상단
	glViewport(0, display_h / 2, display_w / 2, display_h / 2);
	GLfloat Angle{};
	GLfloat Size[2]{};
	glGetFloatv(GL_POINT_SIZE_RANGE, Size);
	glPointSize(Size[0] * 10.f);
	glColor3f(1.f, 0.f, 0.f);
	glBegin(GL_POINTS);
	for(Angle = 0.f; Angle <= 2.f * 3.14f ; Angle += 3.14f / 20.f)
	{
		glVertex2f(0.5f * cosf(Angle), 0.5f * sinf(Angle));
	}
	glEnd();

	// 우측 상단
	glViewport(display_w / 2, display_h / 2, display_w / 2, display_h / 2);
	GLint ScaleFactor = 1;
	GLushort Pattern = 0x00ff;
	GLfloat _Height;
	glColor3f(0.f, 1.f, 0.f);
	glLineWidth(3.f);
	glEnable(GL_LINE_STIPPLE);
	for (_Height = -0.9f; _Height <= 0.9f; _Height += 0.4)
	{
		glLineStipple(ScaleFactor, Pattern);
		glBegin(GL_LINES);
		glVertex3f(-1.f, _Height, 0.f);
		glVertex3f(1.f, _Height, 0.f);
		glEnd();
		ScaleFactor *= 2;
	}
	glDisable(GL_LINE_STIPPLE);

	// 좌측 하단
	glViewport(0, 0, display_w / 2, display_h / 2);
	glLineWidth(10.f);
	glBegin(GL_LINES);
	glColor3f(0.f, 0.f, 1.f);
	glVertex3f(-1.f, 0.f, 0.f);
	glColor3f(0.f, 0.f, 0.f);
	glVertex3f(1.f, 0.f, 0.f);
	glEnd();

	// 우측 하단
	glViewport(display_w / 2, 0, display_w / 2, display_h / 2);
	glShadeModel(GL_SMOOTH);
	glBegin(GL_TRIANGLES);
		glColor3f(0.f, 1.f, 0.f);
		glVertex3f(-0.5f, -0.5f, 0.f);
		glColor3f(0.f, 0.f, 0.f);
		glVertex3f(0.5f, -0.5f, 0.f);
		glColor3f(1.f, 0.f, 0.f);
		glVertex3f(0.f, 0.5f, 0.f);
	glEnd();

	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_9_10_End()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();

	glPointSize(1.f);
	glLineWidth(1.f);

	MAIN_WINDOW->ExplanationContext = L"";
	glNormal3f(0.f, 0.f, 1.f);
}
Description:
좌측 상단은 점을 그리는 예제입니다.
우측 상단은 점표 패턴으로 선분을 그리는 예제입니다.
좌측 하단은 선분을 선형 보간하는 예제입니다.
우측 하단은 다각형 내부를 선형보간으로 채워 그리는 예제입니다.

glPointSize()함수는 점의 크기를 픽셀 단위로 설정합니다.
glLineWidt()h함수는 선의 두께를 픽셀 단위로 설정합니다.
glEnable(GL_LINE_STIPPLE) 함수는 선을 점선 패턴으로 그리는 기능을 활성화합니다.
GLShadeModel(GL_SMOOTH) 함수는 정점 색상을 보간하도록 설정합니다. GL_FLAT은 한 정점의 색상만 사용해서 면 전체를 단색으로 그립니다.

Code 9-15
Input:
void UTOutputWindow::Code_9_15_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);
	glfwMakeContextCurrent(GetGLFWWindow());
	glfwSetKeyCallback(GetGLFWWindow(), Code_9_15_Key);

	Time_9_15 = (GLfloat)glfwGetTime();

	MAIN_WINDOW->ExplanationContext = L"Smooth, Blend 기능을 활용하여 점과 선분을 안티에일리어싱하는 예제입니다.\n";
}

void UTOutputWindow::Code_9_15()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glOrtho(-1.f, 1.f, -1.f, 1.f, -1.f, 1.f);

	if(bChangePalette)
	{
		GLfloat Delta = glfwGetTime() - Time_9_15;
		ElapsedTime_9_15 += Delta;

		if (ElapsedTime_9_15 > 2.f)
		{
			if (++Index_9_15 > 15)
				Index_9_15 = 0;

			Time_9_15 = glfwGetTime();
			ElapsedTime_9_15 = 0.f;
		}
	}

	GLint Red = PALETTE[Index_9_15][0];
	GLint Green = PALETTE[Index_9_15][2];
	GLint Blue = PALETTE[Index_9_15][1];
	glColor3f(Red, Green, Blue);
	
	if (bSmooth_9_15)
	{
		glEnable(GL_POINT_SMOOTH);
		glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);
		glEnable(GL_LINE_SMOOTH);
		glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
	}
	
	if (bBlend_9_15)
	{
		glEnable(GL_BLEND);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	}

	glPointSize(12.f);
	glBegin(GL_POINTS);
	glVertex3f(-0.9f, 0.15f, 0.f);
	glVertex3f(-0.9f, 0.25f, 0.f);
	glVertex3f(-0.9f, 0.35f, 0.f);
	glVertex3f(-0.9f, 0.45f, 0.f);
	glEnd();

	for (GLfloat i = 0.f ; i < 1.f ; i += 0.1f)
	{
		glBegin(GL_LINES);
		glVertex3f(-1.f + i, 1.0f, 0.f);
		glVertex3f(1.f - i, -1.f, 0.f);
		glVertex3f(-1.f, -1.f + i, 0.f);
		glVertex3f(1.f, 1.f - i, 0.f);
		glEnd();
	}

	if (bSmooth_9_15)
	{
		glDisable(GL_POINT_SMOOTH);
		glDisable(GL_LINE_SMOOTH);
	}

	if(bBlend_9_15)
		glDisable(GL_BLEND);

	std::wstringstream wss{};
	wss << L"1 : Smooth 켜기/끄기 (" << (bSmooth_9_15 ? L"켜짐" : L"꺼짐") << L")\n2 : Blend 켜기/끄기 (" << (bBlend_9_15 ? L"켜짐" : L"꺼짐") << L")\n3 : 색깔 바꾸기 (" << (bChangePalette ? L"켜짐" : L"꺼짐") << ")";
	MAIN_WINDOW->DebugContext = wss.str();

	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_9_15_End()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();
	glfwSetKeyCallback(GetGLFWWindow(), nullptr);

	MAIN_WINDOW->ExplanationContext = L"";
	MAIN_WINDOW->DebugContext =  L"";
}

void UTOutputWindow::Code_9_15_Key(GLFWwindow* Window, int Key, int Scancode, int Action, int Mods)
{
	glfwMakeContextCurrent(OUTPUT_WINDOW->GetGLFWWindow());

	if (Action == GLFW_PRESS)
	{
		switch (Key)
		{
		case GLFW_KEY_1:
		{
			OUTPUT_WINDOW->bSmooth_9_15 = !OUTPUT_WINDOW->bSmooth_9_15;
			break;
		}
		case GLFW_KEY_2:
		{
			OUTPUT_WINDOW->bBlend_9_15 = !OUTPUT_WINDOW->bBlend_9_15;
			break;
		}
		case GLFW_KEY_3:
		{
			OUTPUT_WINDOW->bChangePalette = !OUTPUT_WINDOW->bChangePalette;
			break;
		}
		}
	}
}
Description:
glEnable(GL_POINT_SMOOTH), glEnable(GL_LINE_SMOOTH) 를 통해 점, 선에 안티 에일리어싱을 활성화합니다.

glHint(GL_POINT_SMOOTH_HINT, GL_NICEST), glHint(GL_LINE_SMOOTH_HINT, GL_NICEST) 를 통해 가장 좋은 품질을 요청합니다. (GL_FASTEST, GL_DONT_CARE)

glEnable(GL_BLEND) 를 통해 알파 블렌딩 기능을 활성화합니다.

glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) 를 통해 블렌딩 함수를 설정합니다.
최종 색상 = a * 소스 + (1-a) * 배경

Code 10-11
void UTOutputWindow::Code_10_11_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);
    glfwSetKeyCallback(GetGLFWWindow(), UTOutputWindow::Code_10_11_Key);

    MAIN_WINDOW->ExplanationContext = L"두 개의 광원을 사용한 조명 효과 예제입니다";
}

void UTOutputWindow::Code_10_11()
{
    glfwMakeContextCurrent(GetGLFWWindow());
    int display_w, display_h;
    glfwGetWindowSize(GetGLFWWindow(), &display_w, &display_h);
    glViewport(0, 0, display_w, display_h);

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    GLfloat LightPosition0[] = {0.0, 0.0, 2.0, 1.0};
    GLfloat LightPosition1[] = {1.0, 1.0, 1.0, 1.0};
    GLfloat LightDirection1[] = {-0.5, -1.0, -1.0};
    GLfloat SpotAngle1[] = {20.0};
    
    GLfloat global_ambient[] = {0.1f, 0.1f, 0.1f, 1.f};

    GLfloat light0_ambient[] = {0.5f, 0.4f, 0.3f, 1.f};
    GLfloat light0_diffuse[] = {0.5f, 0.4f, 0.3f, 1.f};
    GLfloat light0_specular[] = {1.f, 1.f, 1.f, 1.f};

    GLfloat light1_ambient[] = {0.f, 0.f, 0.f, 1.f};
    GLfloat light1_diffuse[] = {0.5f, 0.2f, 0.3f, 1.f};
    GLfloat light1_specular[] = {0.f, 0.f, 0.f, 1.f};

    GLfloat material_ambient[] = {0.3f, 0.3f, 0.3f, 1.f};
    GLfloat material_diffuse[] = {0.8f, 0.8f, 0.8f, 1.f};
    GLfloat material_specular[] = {0.f, 0.f, 1.f, 1.f};

    glShadeModel(GL_SMOOTH);
    glEnable(GL_DEPTH_TEST);
	glEnable(GL_LIGHTING);        
    
    glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 1.0f);
	glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, 0.05f);
	glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, 0.01f);        
    glLightf(GL_LIGHT1, GL_CONSTANT_ATTENUATION, 1.0f);
	glLightf(GL_LIGHT1, GL_LINEAR_ATTENUATION, 0.05f);
	glLightf(GL_LIGHT1, GL_QUADRATIC_ATTENUATION, 0.01f);
    
    if (bEnableLight0_10_11)
    {
        glEnable(GL_LIGHT0);
        glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);
        glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
        glLightfv(GL_LIGHT0, GL_SPECULAR, light0_specular);

    }
    else
    {
        glDisable(GL_LIGHT0);
    }
    
    if (bEnableLight1_10_11)
    {
        glEnable(GL_LIGHT1);
        glLightfv(GL_LIGHT1, GL_AMBIENT, light1_ambient);
        glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);
        glLightfv(GL_LIGHT1, GL_SPECULAR, light1_specular);

    }
    else
    {
        glDisable(GL_LIGHT1);
    }
    
    glMaterialfv(GL_FRONT, GL_DIFFUSE, material_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, material_specular);
    glMaterialfv(GL_FRONT, GL_AMBIENT, material_ambient);
    glMaterialfv(GL_FRONT, GL_SHININESS, material_shininess);
    
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, global_ambient);
    glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);
    
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-1.f, 1.f, -1.f, 1.f, -1.f, 1.f);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(0.5f, 0.5f, 0.5f, 0.f, 0.f, -1.f, 0.f, 1.f, 0.f);
    glTranslatef(0.3f, 0.3f, 0.f);
    
    glLightfv(GL_LIGHT0, GL_POSITION, LightPosition0);
    glLightfv(GL_LIGHT1, GL_POSITION, LightPosition1);
    glLightfv(GL_LIGHT1, GL_SPOT_DIRECTION, LightDirection1);
    glLightfv(GL_LIGHT1, GL_SPOT_CUTOFF, SpotAngle1);
    glLightf(GL_LIGHT1, GL_SPOT_EXPONENT, 1.0);

    float innerRadius = 0.3f;
    float outerRadius = 0.6f;
    int nsides = 800;
    int rings = 800;

    for (int i = 0; i < rings; i++) {
        float phi = (float)i * 2.f * M_PI / (float)rings;
        float nextPhi = (float)(i + 1) * 2.0f * M_PI / (float)rings;

        glBegin(GL_QUAD_STRIP);
        for (int j = 0; j <= nsides; j++) {
            float theta = (float)j * 2.0f * M_PI / nsides;

            // 첫 번째 원
            float x1 = (outerRadius + innerRadius * cos(theta)) * cos(phi);
            float y1 = (outerRadius + innerRadius * cos(theta)) * sin(phi);
            float z1 = innerRadius * sin(theta);

            // 두 번째 원 (nextPhi)
            float x2 = (outerRadius + innerRadius * cos(theta)) * cos(nextPhi);
            float y2 = (outerRadius + innerRadius * cos(theta)) * sin(nextPhi);
            float z2 = innerRadius * sin(theta);

            glVertex3f(x1, y1, z1);
            glVertex3f(x2, y2, z2);
        }
        glEnd();
    }
    
    std::wstringstream wss{};
    wss << L"1 : 0번 조명 켜기/끄기  (" << (bEnableLight0_10_11 ? L"켜짐)\n" : L"꺼짐)\n")  << L"2 : 1번 조명 켜기/끄기  (" << (bEnableLight1_10_11 ? L"켜짐)\n" : L"꺼짐)\n");
    MAIN_WINDOW->DebugContext = wss.str(); 
    
    glfwSwapBuffers(GetGLFWWindow());
    glFlush();
}

void UTOutputWindow::Code_10_11_End()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();
	glfwSetKeyCallback(GetGLFWWindow(), nullptr);

	MAIN_WINDOW->DebugContext = L"";
}

void UTOutputWindow::Code_10_11_Key(GLFWwindow* Window, int Key, int Scancode, int Action, int Mods)
{
    glfwMakeContextCurrent(OUTPUT_WINDOW->GetGLFWWindow());

    if (Action == GLFW_PRESS)
    {
        switch (Key)
        {
        case GLFW_KEY_1:
            {
                OUTPUT_WINDOW->bEnableLight0_10_11 = !OUTPUT_WINDOW->bEnableLight0_10_11;
                break;
            }
        case GLFW_KEY_2:
            {
                OUTPUT_WINDOW->bEnableLight1_10_11 = !OUTPUT_WINDOW->bEnableLight1_10_11;
                break;
            }
        }
    }
}
Description:
 라이트 0은 따뜻한 포인트 라이트로 하이라이트를 생성하고, 라이트 1은 붉은 스포트라이트로 좁은 영역을 비춥니다. 
 두 라이트를 모두 켜면 조명 효과가 합산되어 더 밝고 복합적인 색감을 만듭니다.
 
Code 10-12
Input:
void UTOutputWindow::Code_10_12_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);
    
    Time_10_12 = (GLfloat)glfwGetTime();
    ElapsedTime_10_12 = 0.f;
    LightSpinAngle_10_12 = 0.f;

	MAIN_WINDOW->ExplanationContext = L"광원의 위치를 회전시켜가며 구의 조명 효과를 구현하는 예제입니다";
}

void UTOutputWindow::Code_10_12()
{
    int display_w{}, display_h{};
    glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
    glViewport(0, 0, display_w, display_h);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    ElapsedTime_10_12 = (GLfloat)glfwGetTime() - (GLfloat)Time_10_12;
    Time_10_12 = (GLfloat)glfwGetTime();
    
    LightSpinAngle_10_12 += ElapsedTime_10_12 * 20.f;
    
    GLfloat LightPosition[] = {0.f, 0.f, 1.5f, 1.f};
    
    GLfloat light0_ambient[] = {0.5f, 0.4f, 0.3f, 1.f};
    GLfloat light0_diffuse[] = {0.8f, 0.7f, 0.6f, 1.f};
    GLfloat light0_specular[] = {1.f, 1.f, 1.f, 1.f};
    
    GLfloat material_ambient[] = {0.4f, 0.4f, 0.4f, 1.f};
    GLfloat material_diffuse[] = {0.9f, 0.9f, 0.9f, 1.f};
    GLfloat material_specular[] = {1.f, 1.f, 1.f, 1.f};
    GLfloat material_shininess[] = {25.f};
   
    
    glShadeModel(GL_SMOOTH);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light0_specular);
    glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 1.0f);
    glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION,   0.f);
    glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION,0.1f);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(40.f, (GLfloat)display_w / (GLfloat)display_h, 0.1f, 100.f);
    
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(0.f, 0.f, 5.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f);
    glPushMatrix();
        glTranslatef(0.f, 0.f, -5.f);
        glPushMatrix();
            glRotatef(LightSpinAngle_10_12, 1.f, 0.f, 0.f);
            glLightfv(GL_LIGHT0, GL_POSITION, LightPosition);
        glPopMatrix();
        
        glColor3f(0.9f, 0.9f, 0.9f);
        for (int i = 0; i < Stacks_10_12; ++i)
        {
            float phi0 = M_PI * float(i) / Stacks_10_12;
            float phi1 = M_PI * float(i + 1) / Stacks_10_12;
        
            glBegin(GL_TRIANGLE_STRIP);
            for (int j = 0; j <= Slices_10_12; ++j)
            {
                float theta = 2.0f * M_PI * float(j) / Slices_10_12;
                auto emit = [&](float phi)
                {
                    float y = std::cos(phi), rxy = std::sin(phi);
                    float x = rxy * std::cos(theta), z = rxy * std::sin(theta);
                    glNormal3f(x, y, z);
                    glTexCoord2f(theta / (2.0f * M_PI), phi / M_PI);
                    glVertex3f(x, y, z);
                };
                emit(phi0);
                emit(phi1);
            }
            glEnd();
        }
    glPopMatrix();
    
	glDisable(GL_DEPTH_TEST);
    glDisable(GL_LIGHTING);
    glDisable(GL_LIGHT0);
    
    glfwSwapBuffers(GetGLFWWindow());
    glFlush();
}

void UTOutputWindow::Code_10_12_End()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();

	MAIN_WINDOW->DebugContext = L"";
}
Description:
버텍스를 움직일 수 있듯이 광원도 움직일 수 있습니다.
시간이 지남에 따라 광원의 위치를 X축 기준으로 회전시켰습니다.

Code 11-7
Input:
void UTOutputWindow::Code_11_7_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);

	for (int i = 0; i < Width_11_7; i++)
	{
		for (int j = 0; j < Height_11_7; j++)
		{
			GLubyte BlackWhite = ((i + j) % 2) * 255;
			Texture_11_7[i][j][0] = BlackWhite;
			Texture_11_7[i][j][1] = BlackWhite;
			Texture_11_7[i][j][2] = BlackWhite;
		}
	}

	MAIN_WINDOW->ExplanationContext = L"텍스처 좌표를 수동으로 매핑한 뒤 래핑 방법을 정의하는 예제입니다.\n";
	MAIN_WINDOW->ExplanationContext = L"여기에서는(0~1) 범위를 벗어난 텍스처에 대해 S 방향은 CLAMP, T 방향은 REPEAT 방법으로 래핑합니다.";
}

void UTOutputWindow::Code_11_7()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetWindowSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);
	
	glOrtho(-1.f, 1.f, -1.f, 1.f, -1.f, 1.f);
	
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, Width_11_7, Height_11_7, 0, GL_RGB, GL_UNSIGNED_BYTE, &Texture_11_7);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
	glEnable(GL_TEXTURE_2D);
	
	glBegin(GL_QUADS);
	glTexCoord2f(0.f, 0.f); glVertex3f(-1.f, -1.f, 0.f);
	glTexCoord2f(0.f, 3.f); glVertex3f(-1.f, 1.f, 0.f);
	glTexCoord2f(3.f, 3.f); glVertex3f(1.f, 1.f, 0.f);
	glTexCoord2f(3.f, 0.f); glVertex3f(1.f, -1.f, 0.f);
	glEnd();

	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_11_7_End()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();

	MAIN_WINDOW->ExplanationContext = L"";
}
Description:
GLAPI void GLAPIENTRY glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
이 함수를 통해 2D 텍스처 이미지를 정의합니다. 여기서는 Width_11_7와 Height_11_7 크기의 RGB 형식의 텍스처 이미지를 생성하고, Texture_11_7 배열에 저장된 데이터를 사용합니다.

GLAPI void GLAPIENTRY glTexParameterf (GLenum target, GLenum pname, GLfloat param);
이 함수들은 텍스처 매개변수를 설정합니다.
- glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP); : 텍스처의 S 좌표(가로 방향)가 0과 1 사이를 벗어날 때 텍스처 좌표를 클램핑합니다.
- glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP); : 텍스처의 T 좌표(세로 방향)가 0과 1 사이를 벗어날 때 텍스처 좌표를 클램핑합니다.
- glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); : 텍스처 확대 시 가장 가까운 이웃 필터링을 사용합니다.
- glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); : 텍스처 축소 시 가장 가까운 이웃 필터링을 사용합니다.

GLAPI void GLAPIENTRY glTexEnvf (GLenum target, GLenum pname, GLfloat param);
이 함수는 텍스처 환경 매개변수를 설정합니다. 여기서는 GL_TEXTURE_ENV_MODE를 GL_DECAL로 설정하여 텍스처가 오브젝트의 색상에 덮어씌워지도록 합니다.
각 인자에 따른 혼합 방법을 표로 나타내면 아래와 같습니다.

C = Color / A = Alpha / f = Fragment / t = Texture / c = CL_TEXTURE_ENV_COLOR의 색

Mode			GL_RGB								GL_RGBA
GL_REPLACE		C = Ct, A = Af						C = Ct, A = At
GL_MOULDATE		C = Cf * Ct, A = Af					C = Cf * Ct, A = Af * At
GL_DECAL		C = Ct, A= Af						C = Cf * (1-At) + Ct * At, A= Af
GL_BLEND		C = Ct * ( 1-Ct ) + Cc * Ct, A=Af	C = Cf * (1-Ct) + Cc * Ct, A = Af * At

glEnable(GL_TEXTURE_2D);
2D 텍스처 매핑 기능을 활성화합니다. 이후의 렌더링에서 텍스처가 적용됩니다.

Code 11-9
Input:
void UTOutputWindow::Code_11_9_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);

	GLfloat mat_diffuse[] = { 0.25, 0.25, 1., 0. };
	GLfloat mat_specular[] = { 1., 1., 1., 0. };
	GLfloat light_position[] = { 10., 10., 20., 1. };
	GLfloat ref_plane[] = { 1.5, 1.5, 1.5, 0. };

	glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
	glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
	glMaterialf(GL_FRONT, GL_SHININESS, 25.f);
	glLightfv(GL_LIGHT0, GL_POSITION, light_position);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glEnable(GL_DEPTH_TEST);
	glShadeModel(GL_SMOOTH);

	GLubyte stripeImage[4 * 32];
	for (int j = 0; j < 32; j++)
	{
		stripeImage[4 * j] = 255;
		stripeImage[4 * j + 1] = (j < 8) ? 0 : 255;
		stripeImage[4 * j + 2] = (j < 8) ? 0 : 255;
		stripeImage[4 * j + 3] = 0;
	}

	glGenTextures(1, &TextureObject_11_7);
	glBindTexture(GL_TEXTURE_1D, TextureObject_11_7);
	glTexImage1D(GL_TEXTURE_1D, 0, 4, 32, 0,
		GL_RGBA, GL_UNSIGNED_BYTE, stripeImage);
	glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
	glTexGenfv(GL_S, GL_OBJECT_PLANE, ref_plane);
	glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
	glEnable(GL_TEXTURE_GEN_S);
	glEnable(GL_TEXTURE_1D);
	
	QuardricObj_11_7 = gluNewQuadric();
	gluQuadricDrawStyle(QuardricObj_11_7, GLU_FILL);

	MAIN_WINDOW->ExplanationContext = L"1D 스트라이프 텍스처를 생성하고, Object Linear 방식의 텍스처 좌표 자동 생성을 사용해 구 표면에 반복되는 줄무늬 패턴을 입히는 예제입니다.\n";
}

void UTOutputWindow::Code_11_9()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w{}, display_h{};
	glfwGetWindowSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);

	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(40.f, (GLfloat)display_w / (GLfloat)display_h, 1.f, 10.f);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	gluLookAt(0.f, 0.f, 5.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f);
	glTranslatef(0.f, 0.f, -1.f);

	gluSphere(QuardricObj_11_7, 1.5f, 40, 40);

	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_11_9_End()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();
	glBindTexture(GL_TEXTURE_1D, 0);
	gluDeleteQuadric(QuardricObj_11_7);

	MAIN_WINDOW->ExplanationContext = L"";
}
Description:
원구에 조명을 가한 결과에 텍스처 매핑을 가하는 예제입니다.

텍스처 기능 사용을 순서대로 정리하면 아래와 같습니다.
1. 텍스처 이미지 생성
	텍스처로 사용할 이미지를 생성합니다. 위 코드에서는 1D 텍스처를 사용하며, 빨강과 파랑 색상이 번갈아 나타나는 스트라이프 이미지를 생성합니다.

2. 텍스처 객체 생성
	glGenTextures 함수를 사용하여 텍스처 객체를 생성합니다. 이 객체는 텍스처 데이터를 저장하는 데 사용됩니다.

3. 텍스처 바인딩
	glBindTexture 함수를 사용하여 생성한 텍스처 객체를 현재 활성화된 텍스처로 바인딩합니다. 이후의 텍스처 관련 함수 호출은 이 바인딩된 텍스처에 적용됩니다.

4. 텍스처 이미지 지정
	glTexImage1D 함수를 사용하여 텍스처 이미지를 텍스처 객체에 업로드합니다. 이 함수는 텍스처의 형식, 크기, 데이터 유형 등을 지정합니다.

5. 텍스처 좌표 생성 설정: glTexGeni 및 glTexGenfv 함수를 사용하여 텍스처 좌표 생성 방식을 설정합니다. 위 코드에서는 객체 공간에서 선형적으로 텍스처 좌표를 생성하도록 설정합니다.

6. 텍스처 매개변수 설정: glTexParameterf 함수를 사용하여 텍스처의 래핑 모드와 필터링 방식을 설정합니다. 래핑 모드는 텍스처 좌표가 0과 1을 벗어날 때의 동작을 정의하며, 필터링 방식은 텍스처가 확대되거나 축소될 때의 픽셀 색상 결정 방식을 정의합니다.

7. 텍스처 환경 설정: glTexEnvf 함수를 사용하여 텍스처 환경 모드를 설정합니다. 위 코드에서는 GL_MODULATE 모드를 사용하여 텍스처 색상이 물체의 재질 색상과 곱해지도록 설정합니다.

8. 텍스처 기능 활성화: glEnable 함수를 사용하여 텍스처 좌표 생성과 텍스처 매핑 기능을 활성화합니다. 이렇게 하면 이후의 렌더링에서 텍스처가 적용됩니다.

정리하자면,
이미지 생성 -> 텍스츠 객체 생성 -> 바인딩 -> 이미지 지정 -> 좌표 생성 설정 -> 매개 변수 설정 -> 환경 설정 -> 기능 활성화

또한 텍스처 바인딩 하기 전에 객체가 먼저 생성되어 있어야하고, 이미지 지정 이후 단계들은 바인딩 이후에 수행되어야 합니다.

Code 11-11
Input:
void UTOutputWindow::Code_11_11_Start()
{
	std::wstring MusicPath = RESOURCE_MANAGER->GetSoundPath() + L"/weightless-flight-short-instrumental.mp3";
	if (std::filesystem::exists(MusicPath))
	{
		MCIERROR err = mciSendStringW((L"open \"" + MusicPath + L"\" type mpegvideo alias bgm").c_str(), NULL, 0, NULL);
		if (err != 0)
		{
			wchar_t errorText[256];
			mciGetErrorStringW(err, errorText, 256);
			std::wstring errorMessage = L"MCI Error: " + std::wstring(errorText);
			MAIN_WINDOW->DebugContext = errorMessage;
		}
		else
		{
			mciSendStringW(L"play bgm repeat", NULL, 0, NULL);
		}
	}

	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);
	glfwSetKeyCallback(GetGLFWWindow(), Code_11_11_Key);

	Time_11_11 = (GLfloat)glfwGetTime();

	MAIN_WINDOW->ExplanationContext = L"스카이 박스와 지형을 렌더링하고, 키보드 입력에 따라 카메라를 이동 및 회전시키는 예제입니다.\n";
	MAIN_WINDOW->DebugContext = L"W : 앞 / A : 왼쪽 / D : 오른쪽 / S : 뒤\nQ : -롤 회전  E : +롤 회전 /J : -요 회전 / L : +요 회전 / I : +피치 회전 / K : -피치 회전\nR : 위 / F : 아래";
}

void UTOutputWindow::Code_11_11()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w{}, display_h{};
	glfwGetWindowSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);
	
	if (Terrain_11_11 == nullptr && Skybox_11_11 == nullptr && Camera_11_11 == nullptr)
	{
		Terrain_11_11 = new Terrain("Resource/Object/space/terrain1.raw", "Resource/Object/space/snow512.bmp", 257, 257);
		Skybox_11_11 = new Skybox();
		Camera_11_11 = new Camera();
	
		Camera_11_11->set(0.f, 1.f, 0.f, 0.f, 1.f, -1.f, 0.f, 1.f, 0.f);
		Camera_11_11->setShape(60.f, (float)display_h / (float)display_w, 0.5f, 1000.f);
	
		Camera_11_11->slide(0.f, 30.f, 0.f);
		Camera_11_11->roll(0.f);
		Camera_11_11->yaw(0.f);
		Camera_11_11->pitch(0.f);
	}
	
	ElapsedTime_11_11 = (GLfloat)glfwGetTime() - Time_11_11;
	Time_11_11 = (GLfloat)glfwGetTime();
	
	if (Actions[LEFT])
		Camera_11_11->slide(-10.f * ElapsedTime_11_11, 0.f, 0.f);
	
	if (Actions[RIGHT])
		Camera_11_11->slide(10.f * ElapsedTime_11_11, 0.f, 0.f);
	
	if(Actions[FORWARD])
		Camera_11_11->slide(0.f, 0.f, 10.f * ElapsedTime_11_11);
	
	if (Actions[BACKWARD])
		Camera_11_11->slide(0.f, 0.f, -10.f * ElapsedTime_11_11);
	
	if(Actions[UP])
		Camera_11_11->slide(0.f, 10.f * ElapsedTime_11_11, 0.f);
	
	if (Actions[DOWN])
		Camera_11_11->slide(0.f, -10.f * ElapsedTime_11_11, 0.f);
	
	if(Actions[PITCH_UP])
		Camera_11_11->pitch(25.f * ElapsedTime_11_11);
	
	if (Actions[PITCH_DOWN])
		Camera_11_11->pitch(-25.f * ElapsedTime_11_11);
	
	if (Actions[YAW_LEFT])
		Camera_11_11->yaw(-25.f * ElapsedTime_11_11);
	
	if (Actions[YAW_RIGHT])
		Camera_11_11->yaw(25.f * ElapsedTime_11_11);
	
	if(Actions[ROLL_LEFT])
		Camera_11_11->roll(25.f * ElapsedTime_11_11);
	
	if (Actions[ROLL_RIGHT])
		Camera_11_11->roll(-25.f * ElapsedTime_11_11);
	
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_CULL_FACE);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glMatrixMode(GL_MODELVIEW);
	
	glPushMatrix();
	glTranslatef(Camera_11_11->eye.x, Camera_11_11->eye.y, Camera_11_11->eye.z);
	Skybox_11_11->draw();
	glPopMatrix();
	
	glPushMatrix();
	glScalef(1.f, 0.2f, 1.f);
	Terrain_11_11->RenderTerrain(Camera_11_11->eye.x, Camera_11_11->eye.z);//지형을 그린다.좌표를 보내주는 이유는 카메라가 위치한 타일블럭의 좌표를 계산하기 위해 ppt참조
	Terrain_11_11->RenderWater();
	glPopMatrix();
	fog(); // 수면아래 안개효과
	
	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_11_11_End()
{
	mciSendStringW(L"close bgm", NULL, 0, NULL);

	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();
	dispose();

	MAIN_WINDOW->ExplanationContext = L"";
	MAIN_WINDOW->DebugContext = L"";
}

void UTOutputWindow::dispose()
{
	delete Terrain_11_11;
	delete Skybox_11_11;
	delete Camera_11_11;

	Terrain_11_11 = nullptr;
	Skybox_11_11 = nullptr;
	Camera_11_11 = nullptr;
}

void UTOutputWindow::fog()
{
	glEnable(GL_FOG);
	glFogi(GL_FOG_MODE, GL_EXP2);

	GLfloat waterFogColor[4] = { 0.f,0.6f,0.6f,5.f };
	GLfloat fogColor[4] = { 0.75f,0.75f,0.75f,0.f };

	if (Camera_11_11->eye.y < (Terrain_11_11->waterLevel * 0.2f))
	{
		glFogfv(GL_FOG_COLOR, waterFogColor);
		glFogf(GL_FOG_DENSITY, 0.75f);
	}
	else
	{
		glFogfv(GL_FOG_COLOR, fogColor);
		glFogf(GL_FOG_DENSITY, 0.01f);
	}
}

void UTOutputWindow::Code_11_11_Key(GLFWwindow* Window, int Key, int Scancode, int Action, int Mods)
{
	switch (Key)
	{

	case GLFW_KEY_1:
	{
		if (Action == GLFW_PRESS)
			OUTPUT_WINDOW->LINE_MODE_11_11 = !OUTPUT_WINDOW->LINE_MODE_11_11;
		break;
	}

	case GLFW_KEY_2:
	{
		if(Action == GLFW_PRESS)
			OUTPUT_WINDOW->FILL_MODE_11_11 = !OUTPUT_WINDOW->FILL_MODE_11_11;
		break;
	}

	case GLFW_KEY_D:
	{
		if (Action == GLFW_PRESS)
			OUTPUT_WINDOW->Actions[RIGHT] = true;
		else if (Action == GLFW_RELEASE)
			OUTPUT_WINDOW->Actions[RIGHT] = false;
		break;
	}

	case GLFW_KEY_A:
	{
		if (Action == GLFW_PRESS)
			OUTPUT_WINDOW->Actions[LEFT] = true;
		else if (Action == GLFW_RELEASE)
			OUTPUT_WINDOW->Actions[LEFT] = false;
		break;
	}

	case GLFW_KEY_S:
	{
		if (Action == GLFW_PRESS)
			OUTPUT_WINDOW->Actions[FORWARD] = true;
		else if (Action == GLFW_RELEASE)
			OUTPUT_WINDOW->Actions[FORWARD] = false;
		break;
	}

	case GLFW_KEY_W:
	{
		if (Action == GLFW_PRESS)
			OUTPUT_WINDOW->Actions[BACKWARD] = true;
		else if (Action == GLFW_RELEASE)
			OUTPUT_WINDOW->Actions[BACKWARD] = false;
		break;
	}

	case GLFW_KEY_SPACE:
	{
		if (Action == GLFW_PRESS)
			OUTPUT_WINDOW->Actions[UP] = true;
		else if (Action == GLFW_RELEASE)
			OUTPUT_WINDOW->Actions[UP] = false;
		break;
	}

	case GLFW_KEY_LEFT_SHIFT:
	{
		if (Action == GLFW_PRESS)
			OUTPUT_WINDOW->Actions[DOWN] = true;
		else if (Action == GLFW_RELEASE)
			OUTPUT_WINDOW->Actions[DOWN] = false;
		break;
	}

	case GLFW_KEY_K:
	{
		if (Action == GLFW_PRESS)
			OUTPUT_WINDOW->Actions[PITCH_UP] = true;
		else if (Action == GLFW_RELEASE)
			OUTPUT_WINDOW->Actions[PITCH_UP] = false;
		break;
	}

	case GLFW_KEY_I:
	{
		if (Action == GLFW_PRESS)
			OUTPUT_WINDOW->Actions[PITCH_DOWN] = true;
		else if (Action == GLFW_RELEASE)
			OUTPUT_WINDOW->Actions[PITCH_DOWN] = false;
		break;
	}

	case GLFW_KEY_J:
	{
		if (Action == GLFW_PRESS)
			OUTPUT_WINDOW->Actions[YAW_LEFT] = true;
		else if (Action == GLFW_RELEASE)
			OUTPUT_WINDOW->Actions[YAW_LEFT] = false;
		break;
	}

	case GLFW_KEY_L:
	{
		if (Action == GLFW_PRESS)
			OUTPUT_WINDOW->Actions[YAW_RIGHT] = true;
		else if (Action == GLFW_RELEASE)
			OUTPUT_WINDOW->Actions[YAW_RIGHT] = false;
		break;
	}

	case GLFW_KEY_Q:
	{
		if (Action == GLFW_PRESS)
			OUTPUT_WINDOW->Actions[ROLL_LEFT] = true;
		else if (Action == GLFW_RELEASE)
			OUTPUT_WINDOW->Actions[ROLL_LEFT] = false;
		break;
	}

	case GLFW_KEY_E:
	{
		if (Action == GLFW_PRESS)
			OUTPUT_WINDOW->Actions[ROLL_RIGHT] = true;
		else if (Action == GLFW_RELEASE)
			OUTPUT_WINDOW->Actions[ROLL_RIGHT] = false;
		break;
	}
	}
}
Description:
이 예제는 간단한 지형 렌더링과 카메라 이동을 구현한 것입니다. 사용자는 키보드 입력을 통해 카메라를 이동하고 회전시킬 수 있습니다. 지형은 높이 맵과 텍스처를 사용하여 렌더링되며, 스카이박스도 함께 그려집니다. 또한, 카메라가 수면 아래에 있을 때 안개 효과가 적용됩니다.
키보드 입력을 처리하는 부분에서는 각 키에 대한 동작을 정의하고, 키가 눌리거나 떼어질 때 해당 동작을 활성화하거나 비활성화합니다. 예를 들어, 'W' 키를 누르면 카메라가 앞으로 이동하고, 'S' 키를 누르면 뒤로 이동합니다. 'A'와 'D' 키는 좌우 이동을 담당하며, 스페이스바와 왼쪽 쉬프트 키는 각각 위아래 이동을 제어합니다. 또한, 'I', 'K', 'J', 'L', 'Q', 'E' 키는 카메라의 피치, 요, 롤 회전을 제어합니다.

스카이박스
스카이박스(Skybox)는 3D 그래픽스에서 사용되는 기법으로, 사용자가 보는 장면의 배경을 구성하는 데 사용됩니다. 스카이박스는 일반적으로 큐브 형태로 만들어지며, 각 면에 하늘, 구름, 산, 우주 등과 같은 배경 이미지를 텍스처로 매핑하여 사용자가 어느 방향을 바라보더라도 자연스러운 배경을 제공할 수 있도록 합니다.
일반적인 3D 객체와는 다르게 후면 제거(culling)를 처리해야 합니다. 일반적으로 3D 객체는 카메라에서 멀어지는 면(후면)을 제거하기 위해 시계방향(CW) 또는 반시계방향(CCW)으로 정의된 면을 사용합니다. 그러나 스카이박스의 경우, 카메라가 내부에 위치하기 때문에 표면의 방향이 반대가 되어야 합니다. 따라서 스카이박스를 그릴 때는 후면 제거를 시계방향(CW)으로 설정하여 카메라 내부에서 볼 때 올바른 면이 렌더링되도록 해야 합니다.

지형
지형을 그리기 위해서는 높이 맵(Height Map)과 텍스처(Texture)를 활용합니다.
높이 맵은 그레이스케일 이미지로, 각 픽셀의 밝기 값이 해당 지형의 높이를 나타냅니다. 밝은 픽셀은 높은 지형을, 어두운 픽셀은 낮은 지형을 의미합니다.
텍스처는 지형의 표면에 적용되는 이미지로, 지형의 시각적 디테일을 향상시킵니다. 

LOD
지형을 렌더링할 때는 높이 맵 데이터를 기반으로 버텍스(Vertex)를 생성하고, 각 버텍스에 텍스처 좌표를 할당합니다. 그런 다음, OpenGL을 사용하여 지형을 그립니다.
LOD 기법을 사용하여, 카메라가 위치한 타일은 더 높은 해상도로 렌더링하고, 멀리 있는 타일은 낮은 해상도로 렌더링하여 성능을 최적화합니다.

수면
수면은 직접 수동 매핑을 통해 버텍스의 위치에 텍스처 위치 좌표를 입력하여 구현했습니다.

안개
카메라가 수면 아래에 있을 때 안개 효과를 적용하여 시각적 깊이감을 향상시킵니다.

Code 12-8
Input:
void UTOutputWindow::Code_12_8_Start()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPushAttrib(GL_ALL_ATTRIB_BITS);
	glfwSetKeyCallback(GetGLFWWindow(), UTOutputWindow::Code_12_8_Key);

	glShadeModel(GL_SMOOTH);
	glClearColor(0.1f, 0.1f, 0.2f, 0.f);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(0.f, 1.f, 0.f, 1.f,-1.f, 1.f);
	glEnable(GL_DEPTH_TEST);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	
	int display_w{}, display_h{};
	glfwGetWindowSize(GetGLFWWindow(), &display_w, &display_h);

	StartX_12_8 = display_w / 8, StartY_12_8 = display_h / 8;
	EndX_12_8 = display_w / 4 + display_w / 8, EndY_12_8 = display_h / 4 + display_h / 8;

	MAIN_WINDOW->ExplanationContext = L"시저 테스트(Scissor Test) 예제입니다. 하단에 씬 전부와 시저 박스를 그리고, 테스트 결과를 상단 뷰포트에 그립니다.\n";
	MAIN_WINDOW->DebugContext = L"화살표 키로 시저 박스 이동";
}

void UTOutputWindow::Code_12_8()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w{}, display_h{};
	glfwGetWindowSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);

	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	
	// 시저 테스트 전 장면
	glEnable(GL_BLEND);
	glViewport(0, 0, display_w, display_h / 2);
	glPushMatrix();
	DrawScene_12_8();
	glPopMatrix();

	// 시저 박스 그리기
	glColor4f(0.8f, 0.8f, 0.8f, 0.5f);
	glBegin(GL_QUADS);
	glVertex3f((GLfloat)StartX_12_8 / (GLfloat)display_w, (GLfloat)StartY_12_8 / (GLfloat)display_h * 2.f, 1.f);
	glVertex3f((GLfloat)StartX_12_8 / (GLfloat)display_w, (GLfloat)EndY_12_8 / (GLfloat)display_h * 2.f, 1.f);
	glVertex3f((GLfloat)EndX_12_8 / (GLfloat)display_w, (GLfloat)EndY_12_8 / (GLfloat)display_h * 2.f, 1.f);
	glVertex3f((GLfloat)EndX_12_8 / (GLfloat)display_w, (GLfloat)StartY_12_8 / (GLfloat)display_h * 2.f, 1.f);
	glEnd();
	glDisable(GL_BLEND);
	
	// 시저 테스트 이후 장면
	glEnable(GL_SCISSOR_TEST);
	int scissorX = StartX_12_8;
	int scissorY = StartY_12_8 + display_h / 2;
	int scissorW = EndX_12_8 - StartX_12_8;
	int scissorH = EndY_12_8 - StartY_12_8;
	glScissor(scissorX, scissorY, scissorW, scissorH);
	glViewport(0, display_h / 2, display_w, display_h / 2);
	glPushMatrix();
	DrawScene_12_8(); 
	glPopMatrix();
	glDisable(GL_SCISSOR_TEST);
	
	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_12_8_End()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	glPopAttrib();
	glfwSetKeyCallback(GetGLFWWindow(), nullptr);
	glBindVertexArray(0);

	MAIN_WINDOW->ExplanationContext = L"";
	MAIN_WINDOW->DebugContext = L"";
}

void UTOutputWindow::Code_12_8_Key(GLFWwindow* Window, int Key, int Scancode, int Action, int Mods)
{
	if(Action != GLFW_PRESS)
		return;

	int display_w{}, display_h{};
	glfwGetWindowSize(OUTPUT_WINDOW->GetGLFWWindow(), &display_w, &display_h);

	switch (Key)
	{
	case GLFW_KEY_RIGHT:
		if (OUTPUT_WINDOW->EndX_12_8 + 10 <= display_w)
		{
			OUTPUT_WINDOW->StartX_12_8 += 10; OUTPUT_WINDOW->EndX_12_8 += 10;
		}
		break;
	case GLFW_KEY_LEFT:
		if (OUTPUT_WINDOW->StartX_12_8 - 10 > 0)
		{
			OUTPUT_WINDOW->StartX_12_8 -= 10; OUTPUT_WINDOW->EndX_12_8 -= 10;
		}
		break;
	case GLFW_KEY_UP:
		if (OUTPUT_WINDOW->EndY_12_8 + 10 < display_h / 2)
		{
			OUTPUT_WINDOW->StartY_12_8 += 10; OUTPUT_WINDOW->EndY_12_8 += 10;
		}
		break;
	case GLFW_KEY_DOWN:
		if (OUTPUT_WINDOW->StartY_12_8 - 10 > 0)
		{
			OUTPUT_WINDOW->StartY_12_8 -= 10; OUTPUT_WINDOW->EndY_12_8 -= 10;
		}
		break;
	}
}

void UTOutputWindow::DrawScene_12_8()
{
	glPushMatrix();
	glColor3f(0.5f, 0.5f, 1.f);
	glBegin(GL_TRIANGLES);
	glVertex3f(0.f, 0.f, 0.f);
	glVertex3f(0.25f, 0.5f, 0.f);
	glVertex3f(0.5f, 0.f, 0.f);
	glEnd();
	glPopMatrix();
	
	glPushMatrix();
	glColor3f(1.f, 0.f, 0.5f);
	glBegin(GL_QUADS);
	glVertex3f(0.5f, 0.3f, 0.f);
	glVertex3f(0.7f, 0.85f, 0.f);
	glVertex3f(0.9f, 0.85f, 0.f);
	glVertex3f(0.7f, 0.3f, 0.f);
	glEnd();
	glPopMatrix();

	glPushMatrix();
	glColor3f(0.9f, 0.9f, 0.1f);
	glTranslatef(0.75f, 0.15f, 0.f);
	
	glBegin(GL_TRIANGLE_FAN);
	constexpr int circle_segments = 100;
	glVertex3f(0.f, 0.f, 0.f);
	for (int i = 0; i <= circle_segments; ++i)
	{
		const float angle = i * 2.0f * 3.1415926f / circle_segments;
		const float x = 0.1f * cosf(angle);
		const float y = 0.1f * sinf(angle);
		glVertex3f(x, y, 0.f);
	}
	glEnd();
	glPopMatrix();

	glPushMatrix();
	glColor3f(0.1f, 0.5f, 0.1f);
	glBegin(GL_TRIANGLES);
	glVertex3f(0.1f, 0.6f, 0.f);
	glVertex3f(0.25f, 0.9f, 0.f);
	glVertex3f(0.25f, 0.6f, 0.f);
	glEnd();
	glPopMatrix();
	
	glPushMatrix();
	glColor3f(0.1f, 0.7f, 0.9f);
	glBegin(GL_TRIANGLES);
	glVertex3f(0.3f, 0.6f, 0.f);
	glVertex3f(0.3f, 0.9f, 0.f);
	glVertex3f(0.55f, 0.6f, 0.f);
	glEnd();
	glPopMatrix();
}
Description:
glEnable(GL_SCISSOR_TEST) 함수는 시저 테스트(Scissor Test)를 활성화하는 데 사용됩니다. 
시저 테스트는 렌더링할 때 특정 영역(사각형) 내에서만 픽셀을 그리도록 제한하는 기능입니다. 
이 기능을 사용하면 화면의 일부분에만 렌더링 작업을 수행할 수 있어 성능 최적화나 특정 효과를 구현하는 데 유용합니다.

glScissor(scissorX, scissorY, scissorW, scissorH) 함수는 시저 테스트에 사용할 사각형 영역을 정의합니다. 
- scissorX: 시저 사각형의 왼쪽 하단 모서리의 X 좌표입니다.
- scissorY: 시저 사각형의 왼쪽 하단 모서리의 Y 좌표입니다.
- scissorW: 시저 사각형의 너비입니다.
- scissorH: 시저 사각형의 높이입니다.
유의할 점은, Y 좌표는 OpenGL의 좌표계에서 화면의 하단이 0이고 상단이 최대값인 점입니다.
또한 파라미터로 들어가는 좌표는 지엘의 화면 좌표계를 기준으로 한다는 점입니다.

뷰포트의 하단에는 모든 씬을 그리며, 상단에는 시저 테스트를 적용한 씬을 그립니다.
시저 테스트가 적용된 상단 뷰포트에서는 정의된 시저 사각형 영역 내에서만 픽셀이 그려지며, 그 외의 영역은 렌더링되지 않습니다.
