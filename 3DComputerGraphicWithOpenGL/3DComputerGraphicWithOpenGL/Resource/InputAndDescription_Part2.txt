// Copyright 2025. Team Unique Turtle ; https://github.com/biomaticals. All rights reserved.
// All contents cannot be copied, distributed, revised.


Code 5-2
Input:
void UTOutputWindow::Code_5_2_Start()
{
	ResetAll();
	MAIN_WINDOW->ExplanationContext = L"색 버퍼를 초기화한 뒤, 직접 정의한 정점들을 이용해 화면 중앙에 2D 폴리곤을 렌더링 하는 기초 예제입니다.";
}

void UTOutputWindow::Code_5_2()
{
	ResetAll();
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);
	
	glClearColor(0.f, 0.f, 0.f, 1.f);
	glClear(GL_COLOR_BUFFER_BIT);
	
	glBegin(GL_POLYGON);
	glVertex3f(-0.5f, -0.5f, 0.f);
	glVertex3f(0.5f, -0.5, 0.f);
	glVertex3f(0.5f, 0.5f, 0.f);
	glVertex3f(-0.5f, 0.5f, 0.f);
	glEnd();
	
	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_5_2_End()
{
	ResetAll();
	MAIN_WINDOW->ExplanationContext = L"";
}
Description:
glClear(GL_COLOR_BUFFER_BIT) 함수는 컬러 버퍼를 지워서(초기화해서) 배경색을 설정합니다.

glBegin(GL_POLYGON)과 glEnd() 함수는 다각형(여기서는 사각형)을 정의하며, glVertex3f() 함수를 사용해 각 꼭짓점 좌표를 지정합니다.

glFlush() 함수는 OpenGL 명령들이 유한한 시간 안에 실행되도록 강제로 처리합니다.

Code 5-4
Input:
void UTOutputWindow::Code_5_4()
{
	ResetAll();
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);
	
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(1.f, 1.f, 1.f);
	glClearColor(0.f, 0.f, 0.f, 1.f);
	
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-1.f, 1.f, -1.f, 1.f, -1.f, 1.f);
	
	glBegin(GL_POLYGON);
	glVertex3f(-0.5f, -0.5f, 0.f);
	glVertex3f(0.5f, -0.5, 0.f);
	glVertex3f(0.5f, 0.5f, 0.f);
	glVertex3f(-0.5f, 0.5f, 0.f);
	glEnd();
	
	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_5_4_End()
{
	ResetAll();
	MAIN_WINDOW->ExplanationContext = L"";
}
Description:
glColor3f(1.f, 1.f, 1.f) 함수는 현재 그리기 색상을 흰색(RGB 값 1, 1, 1)으로 설정합니다.

glClearColor(0.f, 0.f, 0.f, 1.f) 함수는 화면을 지울 때 사용할 배경색을 검정색(RGBA 값 0, 0, 0, 1)으로 설정합니다.

glMatrixMode(GL_PROJECTION) 함수는 현재 행렬 모드를 투영 행렬 모드로 변경합니다. 이 모드는 화면에 보이는 공간(뷰잉 볼륨)을 정의할 때 사용됩니다.

GL_PROJECTION은 투영 행렬 스택을 의미하는 상수입니다.

GL_MODELVIEW는 모델뷰 행렬 스택을 의미하는 상수입니다.

GL_TEXTURE는 텍스처 행렬 스택을 의미하는 상수입니다.

glLoadIdentity() 함수는 현재 행렬을 단위 행렬로 초기화합니다.

glOrtho(-1.f, 1.f, -1.f, 1.f, -1.f, 1.f) 함수는 왼쪽, 오른쪽, 아래, 위, 근평면, 원평면을 지정하여 2D 직교 투영 행렬을 정의합니다.

Code 5-5
Input:
void UTOutputWindow::Code_5_5_Start()
{
	ResetAll();
	glfwMakeContextCurrent(GetGLFWWindow());
	glfwGetFramebufferSize(OUTPUT_WINDOW->GetGLFWWindow(), &Width_5_6, &Height_5_6);
	glfwSetFramebufferSizeCallback(GetGLFWWindow(), Code_5_5_Reshape);

	MAIN_WINDOW->ExplanationContext = L"색 버퍼를 초기화 한 뒤, 창의 크기가 변경될 때마다 호출되는 콜백 함수를 등록합니다. 그리고 직접 정의한 정점들을 이용해 화면 중앙에 2D 폴리곤을 렌더링합니다.";
}

void UTOutputWindow::Code_5_5()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);

	glClearColor(0.f, 0.f, 0.f, 1.f);
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(0.5f, 0.5f, 0.5f);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-1.f , 1.f, -1.f, 1.f, -1.f, 1.f);

	glBegin(GL_POLYGON);
	glVertex3f(-0.5f, -0.5f, 0.f);
	glVertex3f(0.5f, -0.5f, 0.f);
	glVertex3f(0.5f, 0.5f, 0.f);
	glVertex3f(-0.5f, 0.5f, 0.f);
	glEnd();

	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_5_5_End()
{
	ResetAll();
	glfwMakeContextCurrent(GetGLFWWindow());
	glfwSetFramebufferSizeCallback(GetGLFWWindow(), NULL);

	MAIN_WINDOW->ExplanationContext = L"";
}

void UTOutputWindow::Code_5_5_Reshape(GLFWwindow* Window, int NewWidth, int NewHeight)
{
	glfwMakeContextCurrent(OUTPUT_WINDOW->GetGLFWWindow());
	glViewport(0, 0, NewWidth, NewHeight);
	
	GLfloat WidthFactor = (GLfloat)NewWidth / (GLfloat)(OUTPUT_WINDOW->Width_5_6);
	GLfloat HeightFactor = (GLfloat)NewHeight / (GLfloat)(OUTPUT_WINDOW->Height_5_6);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-1.f * WidthFactor, 1.f * WidthFactor, -1.f * HeightFactor, 1.f * HeightFactor, -1.f, 1.f);
}
Description:
glfwSetFramebufferSizeCallback(GetGLFWWindow(), Code_5_5_Reshape) 함수는 창의 크기가 변경될 때 호출되는 콜백 함수를 설정합니다. 여기서는 Code_5_5_Reshape 함수가 콜백으로 지정되어 있습니다.

glfwSetFramebufferSizeCallback(GetGLFWWindow(), NULL) 함수는 이전에 설정된 프레임버퍼 크기 변경 콜백을 해제합니다.

glViewport(0, 0, NewWidth, NewHeight) 함수는 새로운 창 크기에 맞게 뷰포트를 설정합니다.

Code 5-6
Input:
void UTOutputWindow::Code_5_6_Start()
{
	ResetAll();
	glfwSetKeyCallback(GetGLFWWindow(), Code_5_6_Key);

	MAIN_WINDOW->ExplanationContext = L"색 버퍼를 초기화 한 뒤, 키보드 입력을 처리하는 콜백 함수를 등록합니다. 그리고 직접 정의한 정점들을 이용해 화면 중앙에 2D 폴리곤을 렌더링합니다. 'Q' 키를 누르면 프로그램이 종료됩니다.";
}

void UTOutputWindow::Code_5_6()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);
	
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(0.5f, 0.5f, 0.5f);
	glClearColor(0.f, 0.f, 0.f, 1.f);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-1.f, 1.f, -1.f, 1.f, -1.f, 1.f);
	
	glBegin(GL_POLYGON);
	glVertex3f(-0.5f, -0.5f, 0.f);
	glVertex3f(0.5f, -0.5, 0.f);
	glVertex3f(0.5f, 0.5f, 0.f);
	glVertex3f(-0.5f, 0.5f, 0.f);
	glEnd();
	
	glfwSwapBuffers(GetGLFWWindow());
	glFlush();
}

void UTOutputWindow::Code_5_6_End()
{
	ResetAll();
	glfwMakeContextCurrent(GetGLFWWindow());
	glfwSetKeyCallback(GetGLFWWindow(), NULL);

	MAIN_WINDOW->ExplanationContext = L"";
}

void UTOutputWindow::Code_5_6_Key(GLFWwindow* Window, int Key, int Scancode, int Action, int Mods)
{
	switch (Key)
	{
	case GLFW_KEY_Q:
	{
		if (Action == GLFW_PRESS)
		{
			exit(0);
			break;
		}
		break;
	}
	}
}
Description:
GLFWkeyfun glfwSetKeyCallback(GLFWwindow* window, GLFWkeyfun cbfun) 함수는 키보드 입력 이벤트를 처리하기 위한 콜백 함수를 설정합니다. 여기서 cbfun은 키 이벤트가 발생할 때 호출될 함수의 포인터입니다.

Code 5-7
Input:
void UTOutputWindow::Code_5_7_Start()
{
	ResetAll();
	glfwMakeContextCurrent(GetGLFWWindow());
	glfwSetMouseButtonCallback(GetGLFWWindow(), Code_5_7_MouseButton);
	glfwSetCursorPosCallback(GetGLFWWindow(), Code_5_7_CursorPosition);

	TopLeftX_5_7 = -0.85;
	TopLeftY_5_7 = 0.85;
	BottomRightX_5_7 = 0.85;
	BottomRightY_5_7 = -0.85;

	MAIN_WINDOW->ExplanationContext = L"색 버퍼를 초기화 한 뒤, 마우스 입력을 처리하는 콜백 함수를 등록합니다. 마우스 왼쪽 버튼을 클릭한 위치를 사각형의 왼쪽 위 꼭지점으로, 마우스를 이동한 위치를 사각형의 오른쪽 아래 꼭지점으로 설정하여 사각형을 렌더링합니다.";
}

void UTOutputWindow::Code_5_7()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(0.5f, 0.5f, 0.5f);
	glClearColor(0.f, 0.f, 0.f, 1.f);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-1.f, 1.f, -1.f, 1.f, -1.f, 1.f);
	glBegin(GL_POLYGON);
	glVertex3f(TopLeftX_5_7, TopLeftY_5_7, 0.f);
	glVertex3f(BottomRightX_5_7, TopLeftY_5_7, 0.f);
	glVertex3f(BottomRightX_5_7, BottomRightY_5_7, 0.f);
	glVertex3f(TopLeftX_5_7, BottomRightY_5_7, 0.f);
	glEnd();
	glFlush();
	glfwSwapBuffers(GetGLFWWindow());
}

void UTOutputWindow::Code_5_7_End()
{
	ResetAll();
	glfwMakeContextCurrent(GetGLFWWindow());
	glfwSetMouseButtonCallback(GetGLFWWindow(), NULL);
	glfwSetCursorPosCallback(GetGLFWWindow(), NULL);

	TopLeftX_5_7 = -0.85;
	TopLeftY_5_7 = -0.85;
	BottomRightX_5_7 = 0.85;
	BottomRightY_5_7 = 0.85;

	MAIN_WINDOW->ExplanationContext = L"";
}

void UTOutputWindow::Code_5_7_MouseButton(GLFWwindow* Window, int button, int action, int mods)
{
	if(button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS)
	{
		glfwMakeContextCurrent(OUTPUT_WINDOW->GetGLFWWindow());
		double xpos, ypos;
		glfwGetCursorPos(Window, &xpos, &ypos);

		std::array<double, 2> OrthoCoords = CursorPosToOrthoCoords(Window, std::array<double, 2>{xpos, ypos});

		OUTPUT_WINDOW->TopLeftX_5_7 = OrthoCoords[0];
		OUTPUT_WINDOW->TopLeftY_5_7 = OrthoCoords[1];
	}
}

void UTOutputWindow::Code_5_7_CursorPosition(GLFWwindow* Window, double xpos, double ypos)
{
	std::array<double, 2> OrthoCoords = CursorPosToOrthoCoords(Window, std::array<double, 2>{xpos, ypos});

	OUTPUT_WINDOW->BottomRightX_5_7 = OrthoCoords[0];
	OUTPUT_WINDOW->BottomRightY_5_7 = OrthoCoords[1];
}
Description:
GLFWmousebuttonfun glfwSetMouseButtonCallback(GLFWwindow* window, GLFWmousebuttonfun cbfun) 함수는 마우스 버튼 이벤트를 처리하기 위한 콜백 함수를 설정합니다. 여기서 cbfun은 마우스 버튼 이벤트가 발생할 때 호출될 함수의 포인터입니다.
GLFWcursorposfun glfwSetCursorPosCallback(GLFWwindow* window, GLFWcursorposfun cbfun) 함수는 마우스 커서 위치 변경 이벤트를 처리하기 위한 콜백 함수를 설정합니다. 여기서 cbfun은 커서 위치가 변경될 때 호출될 함수의 포인터입니다.

커서의 좌표계는 윈도우 좌표계 또는 픽셀 좌표계라 불리고, 창의 왼쪽 상단이 (0, 0)이고 오른쪽 하단이 (창의 너비, 창의 높이)인 픽셀 단위로 표현됩니다.
glVertexfloat3f에 들어가는 점의 좌표계는 객체 좌표계이며, 이는 아직 모델-뷰 변환이나 투영 변환이 적용되지 않은 상태의 좌표계입니다. 객체 좌표계에서의 좌표는 일반적으로 -1.0에서 1.0 사이의 값으로 표현됩니다.

여기에서는 모델 변환이 없고, 뷰 변환도 없으며, 투영 변환은 직교 투영(glOrtho)으로 설정되어 있습니다. 또한 그 값도 단위 행렬입니다.
따라서 객체 좌표계의 좌표가 그대로 클립 좌표계로 전달됩니다. 클립 좌표계는 -1.0에서 1.0 사이의 값으로 표현되며, 이 범위를 벗어나는 좌표는 클리핑됩니다.

Code 5-13
Input:
inline static GLfloat Vertices_5_13[8][3]
{
	{ -0.25f, -0.25f, 0.25f },
	{ -0.25f,  0.25f, 0.25f },
	{  0.25f,  0.25f, 0.25f },
	{  0.25f, -0.25f, 0.25f },
	{ -0.25f, -0.25f, -0.25f },
	{ -0.25f,  0.25f, -0.25f },
	{  0.25f,  0.25f, -0.25f },
	{  0.25f, -0.25f, -0.25f }
};

inline static GLfloat Colors_5_13[8][3]
{
	{ 0.2f, 0.2f, 0.2f },
	{ 1.0f, 0.0f, 0.0f },
	{ 1.0f, 1.0f, 0.0f },
	{ 0.0f, 1.0f, 0.0f },
	{ 0.0f, 0.0f, 1.0f },
	{ 1.0f, 0.0f, 1.0f },
	{ 1.0f, 1.0f, 1.0f },
	{ 0.0f, 1.0f, 1.0f }
};
inline static GLubyte VertexList_5_13[24]
{
	0, 3, 2, 1,
	2, 3, 7, 6,
	0, 4, 7, 3,
	1, 2, 6, 5,
	4, 5, 6, 7,
	0, 1, 5, 4
};

void UTOutputWindow::Code_5_13_Start()
{
	ResetAll();
	MAIN_WINDOW->ExplanationContext = L"정점 배열과 색상 배열, 인덱스 배열을 사용하여 3D 큐브를 렌더링하는 예제입니다.\n";
	MAIN_WINDOW->ExplanationContext += L"폴리곤의 와인딩 순서를 반시계(CCW)로 설정하여 앞면을 정의하고,\n";
	MAIN_WINDOW->ExplanationContext += L"백페이스 컬링을 활성화하여 카메라에서 보이지 않는 뒷면을 제거합니다.";
}

void UTOutputWindow::Code_5_13()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);
	glViewport(0, 0, display_w, display_h);
	
	glClearColor(0.f, 0.f, 0.f, 1.f);
	glClear(GL_COLOR_BUFFER_BIT);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-1.f, 1.f, -1.f, 1.f, -1.f, 1.f);
	
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glRotatef(30.f, 1.f, 0.f, 1.1);
	glFrontFace(GL_CCW);
	glEnable(GL_CULL_FACE);

	glEnableClientState(GL_COLOR_ARRAY);
	glEnableClientState(GL_VERTEX_ARRAY);
	glColorPointer(3, GL_FLOAT, 0, Colors_5_13);
	glVertexPointer(3, GL_FLOAT, 0, Vertices_5_13);

	for (GLint i = 0; i < 6; i++)
		glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, &VertexList_5_13[4 * i]);

	glDisableClientState(GL_COLOR_ARRAY);
	glDisableClientState(GL_VERTEX_ARRAY);
	glLoadIdentity();
	glFlush();
	glfwSwapBuffers(GetGLFWWindow());
}

void UTOutputWindow::Code_5_13_End()
{
	ResetAll();
	glfwMakeContextCurrent(GetGLFWWindow());
}
Description:
glFrontFace(GL_CCW) 함수는 면의 앞면을 정의합니다. 일반적으로 반시계 방향(GL_CCW)으로 정의된 면이 앞면으로 간주됩니다. 시계 방향(GL_CW)으로 정의된 면은 뒷면으로 간주됩니다.
glEnableClientState(GL_COLOR_ARRAY) 함수는 색상 배열을 사용하도록 설정합니다. 이를 통해 정점마다 다른 색상을 지정할 수 있습니다.
glEnableClientState(GL_VERTEX_ARRAY) 함수는 정점 배열을 사용하도록 설정합니다. 이를 통해 정점 데이터를 배열로부터 가져올 수 있습니다.
glColorPointer(3, GL_FLOAT, 0, Colors_5_13) 함수는 색상 배열을 지정합니다. 여기서 3은 각 색상이 RGB로 구성되어 있음을 나타내고, GL_FLOAT는 색상 데이터의 형식을 나타내며, 0은 각 색상 사이의 간격(스트라이드)을 나타냅니다. 마지막 매개변수는 실제 색상 데이터 배열의 포인터입니다.
glVertexPointer(3, GL_FLOAT, 0, Vertices_5_13) 함수는 정점 배열을 지정합니다. 여기서 3은 각 정점이 3D 좌표(x, y, z)로 구성되어 있음을 나타내고, GL_FLOAT는 정점 데이터의 형식을 나타내며, 0은 각 정점 사이의 간격(스트라이드)을 나타냅니다. 마지막 매개변수는 실제 정점 데이터 배열의 포인터입니다.

Code 5-14
Input:
void UTOutputWindow::Code_5_14_Start()
{
	MyListID_5_14 = glGenLists(1);
	glNewList(MyListID_5_14, GL_COMPILE);
	glBegin(GL_POLYGON);
	glColor3f(0.5f, 0.5f, 0.5f);
	glVertex3f(-0.5f, -0.5f, 0.0f);
	glVertex3f(0.5f, -0.5f, 0.0f);
	glVertex3f(0.5f, 0.5f, 0.0f);
	glVertex3f(-0.5f, 0.5f, 0.0f);
	glEnd();
	glEndList();
}

void UTOutputWindow::Code_5_14()
{
	glClearColor(0.f, 0.f, 0.f, 1.f);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-1.f, 1.f, -1.f, 1.f, -1.f, 1.f);
	glClear(GL_COLOR_BUFFER_BIT);
	glCallList(MyListID_5_14);
	glFlush();
	glfwSwapBuffers(GetGLFWWindow());
}
Description:
GLuint glGenLists(GLsizei range) 함수는 새로운 디스플레이 리스트 식별자를 생성합니다. 여기서 range는 생성할 디스플레이 리스트의 개수를 나타냅니다. 이 함수는 생성된 디스플레이 리스트의 첫 번째 식별자를 반환합니다.
void glNewList(GLuint list, GLenum mode) 함수는 새로운 디스플레이 리스트를 시작합니다. 여기서 list는 디스플레이 리스트의 식별자이고, mode는 디스플레이 리스트의 동작 모드를 지정합니다. GL_COMPILE 모드는 명령을 컴파일만 하고 즉시 실행하지 않음을 의미합니다.
void glEndList() 함수는 현재 디스플레이 리스트의 정의를 종료합니다.
void glCallList(GLuint list) 함수는 지정된 디스플레이 리스트를 실행합니다. 여기서 list는 실행할 디스플레이 리스트의 식별자입니다.

Code 5-15
Input:
void UTOutputWindow::Code_5_15_Start()
{
	ResetAll();
	glfwMakeContextCurrent(GetGLFWWindow());
	glfwSetCursorPosCallback(GetGLFWWindow(), Code_5_15_CursorPosition);
	glfwSetKeyCallback(GetGLFWWindow(), Code_5_15_Key);
	const std::string basepath = "Resource/Object/Wood_Table/";
	const std::string texbasepath = "Resource/Object/Wood_Table/textures";
	const std::string objpath = basepath + "Wood_Table.obj";
	LoadObjWithMaterial(objpath, vertices_5_15, indices_5_15, materials_5_15);

	glClearColor(0.4f, 0.4f, 0.4f, 1.f);
	GLfloat mat_diffuse[] = { 0.5f, 0.4f, 0.3f, 1.f };
	GLfloat mat_specular[] = { 1.f, 1.f, 1.f, 1.f };
	GLfloat mat_ambient[] = { 0.5f, 0.4f, 0.3f, 1.f };
	GLfloat mat_shininess[] = { 15.f };
	GLfloat light_specular[] = { 1.f, 1.f, 1.f, 1.f };
	GLfloat light_diffuse[] = { 0.8f, 0.8f, 0.8f, 1.f };
	GLfloat light_ambient[] = { 0.3f, 0.3f, 0.3f, 1.f };
	light_position_5_15[0] = 5.f;
	light_position_5_15[1] = 5.f;
	light_position_5_15[2] = 0.f;
	light_position_5_15[3] = 1.f;
	glShadeModel(GL_SMOOTH);
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glEnable(GL_NORMALIZE);
	glDisable(GL_COLOR_MATERIAL);
	glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 1.0f);
	glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, 0.05f);
	glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, 0.01f);

	glLightfv(GL_LIGHT0, GL_POSITION, light_position_5_15);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
	glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
	glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
	glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
	glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
	glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
	glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 1.0f);
	glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, 0.1f);
	glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, 0.01f);

	FlatShadeMode_5_15 = false;
	WireframeMode_5_15 = false;

	MAIN_WINDOW->ExplanationContext = L"OBJ 모델과 머티리얼 정보를 로드하여 텍스처, 노멀, 조명 계산을 포함한 전통적인 OpenGL 고정 파이프라인 방식으로 3D 오브젝트를 렌더링하는 예제입니다.\n";
	MAIN_WINDOW->ExplanationContext += L"마우스 입력을 통해 카메라의 위치를 구면 좌표계로 변환하여 모델 주위를 회전하며 관찰할 수 있으며,\n";
	MAIN_WINDOW->ExplanationContext += L"광원 위치, 확산광·정반사광·환경광 등의 머티리얼 속성을 설정하여 실제와 유사한 조명 효과를 구현합니다.\n";
	MAIN_WINDOW->ExplanationContext += L"렌더링 시에는 텍스처 좌표, 노멀 벡터, 정점 위치를 기반으로 삼각형 단위로 모델을 그리며,\n";
	MAIN_WINDOW->ExplanationContext += L"쉐이딩 모드와 폴리곤 모드는 런타임에서 토글할 수 있도록 구성되어 있습니다.";
}

void UTOutputWindow::Code_5_15()
{
	glfwMakeContextCurrent(GetGLFWWindow());
	int display_w, display_h;
	glfwGetFramebufferSize(GetGLFWWindow(), &display_w, &display_h);

	glViewport(0, 0, display_w, display_h);

	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

 	glm::vec3 eye{};
 	float theta_w = (cursor_xpos_5_15 / display_w) * 2.f * glm::pi<float>();
 	float theta_h = (cursor_ypos_5_15 / display_h) * glm::pi<float>();
 	eye.x = std::sin(theta_w) * 5.f;
 	eye.y = std::cos(theta_h) * 5.f;
 	eye.z = std::cos(theta_w) * 5.f;

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glm::mat4 projection = glm::perspective(
		glm::radians(45.0f),
		(float)display_w / (float)display_h,
		0.1f,
		10000.0f
	);
	glLoadMatrixf(&projection[0][0]);
	// 뷰 행렬 설정
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glm::mat4 view = glm::lookAt(
		eye,
		glm::vec3(0.f, 0.f, 0.f),
		glm::vec3(0.0f, 1.0f, 0.0f)
	);
	glLoadMatrixf(&view[0][0]);

	// 조명 위치는 여기서 다시 설정
	glLightfv(GL_LIGHT0, GL_POSITION, light_position_5_15);
	glEnable(GL_TEXTURE_2D);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
	glGetError();
	if (!materials_5_15.empty() && materials_5_15[0].textureId != 0)
	{
		glBindTexture(GL_TEXTURE_2D, materials_5_15[0].textureId);
	}

	if (FlatShadeMode_5_15)
	{
		glShadeModel(GL_SMOOTH);
	}
	else
	{
		glShadeModel(GL_FLAT);
	}

	if (WireframeMode_5_15)
	{
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	}
	else
	{
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	}

 	glBegin(GL_TRIANGLES);
 	for (size_t i = 0; i < indices_5_15.size(); i++)
 	{
 		const Vertex& v = vertices_5_15[indices_5_15[i]];
 		glTexCoord2f(v.texcoord.x, v.texcoord.y);
 		glNormal3f(v.normal.x, v.normal.y, v.normal.z);
 		glVertex3f(v.pos.x, v.pos.y, v.pos.z);
 	}
 	glEnd();

	glfwSwapBuffers(GetGLFWWindow());
	glFlush();

	MAIN_WINDOW->DebugContext = L"Q : 종료\n";
	MAIN_WINDOW->DebugContext  = L"1 : 쉐이드 모드 전환(현재 : ";
	MAIN_WINDOW->DebugContext += (FlatShadeMode_5_15 ? L"플랫 쉐이딩)" : L"스무스 쉐이딩)\n");
	MAIN_WINDOW->DebugContext += L"2 : 폴리곤 모드 전환(현재:";
	MAIN_WINDOW->DebugContext += (WireframeMode_5_15 ? L"와이어프레임)" : L"채워진 폴리곤)\n");
}

void UTOutputWindow::Code_5_15_End()
{
	ResetAll();
	glfwMakeContextCurrent(GetGLFWWindow());

	glfwSetMouseButtonCallback(GetGLFWWindow(), nullptr);
	glfwSetCursorPosCallback(GetGLFWWindow(), nullptr);
	glfwSetKeyCallback(GetGLFWWindow(), nullptr);

	OUTPUT_WINDOW->WireframeMode_5_15 = true;
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

	OUTPUT_WINDOW->FlatShadeMode_5_15 = true;
	glShadeModel(GL_SMOOTH);

	glClearColor(0.f, 0.f, 0.f, 1.f);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_LIGHTING);
	glDisable(GL_LIGHT0);
	glDisable(GL_NORMALIZE);
	glDisable(GL_COLOR_MATERIAL);
	glDisable(GL_TEXTURE_2D);
	for (auto& material : materials_5_15)
	{
		if (material.textureId != 0)
		{
			glDeleteTextures(1, &material.textureId);
			material.textureId = 0;
		}
	}
	glBindTexture(GL_TEXTURE_2D, 0);
	glFlush();
	glGetError();

	MAIN_WINDOW->ExplanationContext = L"";
	MAIN_WINDOW->DebugContext = L"";
}

void UTOutputWindow::Code_5_15_Reshape(GLFWwindow* Window, int NewWidth, int NewHeight)
{
	glViewport(0, 0, NewWidth, NewHeight);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-1.f, 1.f, -1.f, 1.f, -1.f, 1.f);
}

void UTOutputWindow::Code_5_15_Key(GLFWwindow* Window, int Key, int Scancode, int Action, int Mods)
{
	if (Action != GLFW_PRESS)
		return;

	switch (Key)
	{
	case GLFW_KEY_Q:
	{
		exit(0);
		break;
	}
	case GLFW_KEY_1:
	{
		if (OUTPUT_WINDOW->FlatShadeMode_5_15)
		{
			OUTPUT_WINDOW->FlatShadeMode_5_15 = false;
		}
		else
		{
			OUTPUT_WINDOW->FlatShadeMode_5_15 = true;
		}
		break;
	}
	case GLFW_KEY_2:
	{
		if (OUTPUT_WINDOW->WireframeMode_5_15)
		{
			OUTPUT_WINDOW->WireframeMode_5_15 = false;
		}
		else
		{
			OUTPUT_WINDOW->WireframeMode_5_15 = true;
		}
	}
	}
}

void UTOutputWindow::Code_5_15_CursorPosition(GLFWwindow* Window, double xpos, double ypos)
{
	CursorPosToOrthoCoords(OUTPUT_WINDOW->GetGLFWWindow(), std::array<double,2>{xpos, ypos});
	OUTPUT_WINDOW->cursor_xpos_5_15 = xpos;
	OUTPUT_WINDOW->cursor_ypos_5_15 = ypos;
}
Description:
LoadObjWithMaterial(objpath, vertices_5_15, indices_5_15, materials_5_15) 함수는 지정된 OBJ 파일을 로드하고, 정점 데이터(vertices_5_15), 인덱스 데이터(indices_5_15), 재질 정보(materials_5_15)를 추출합니다.

glm::perspective 함수는 원근 투영 행렬을 생성합니다. 이 함수는 시야각, 종횡비, 근평면 및 원평면 거리를 매개변수로 받아 투영 행렬을 반환합니다.
glm::lookAt 함수는 뷰 행렬을 생성합니다. 이 함수는 카메라 위치(eye), 바라보는 대상(center), 업 벡터(up)를 매개변수로 받아 뷰 행렬을 반환합니다.

glEnable(GL_TEXTURE_2D) 함수는 2D 텍스처 매핑을 활성화합니다. 이를 통해 텍스처를 사용하여 표면에 이미지를 적용할 수 있습니다.
glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE) 함수는 텍스처 환경 설정을 지정합니다. 여기서는 텍스처 색상과 재질 색상을 곱하는 모드인 GL_MODULATE를 설정합니다.
glBindTexture(GL_TEXTURE_2D, materials_5_15[0].textureId) 함수는 지정된 텍스처 ID를 현재 바인딩된 2D 텍스처로 설정합니다. 이를 통해 이후의 렌더링에서 해당 텍스처가 사용됩니다.

glShadeModel(GL_SMOOTH) 함수는 셰이딩 모델을 부드러운 셰이딩으로 설정합니다. 부드러운 셰이딩은 정점 색상을 보간하여 면의 색상을 계산합니다.
glShadeModel(GL_FLAT) 함수는 셰이딩 모델을 평면 셰이딩으로 설정합니다. 평면 셰이딩은 면의 첫 번째 정점의 색상을 사용하여 면 전체의 색상을 계산합니다.

glPolygonMode(GL_FRONT_AND_BACK, GL_FILL) 함수는 폴리곤의 앞면과 뒷면을 모두 채우는 모드로 설정합니다. 이를 통해 폴리곤이 실린더처럼 보이게 됩니다.
glPolygonMode(GL_FRONT_AND_BACK, GL_LINE) 함수는 폴리곤의 앞면과 뒷면을 모두 선 모드로 설정합니다. 이를 통해 폴리곤의 윤곽선만 그려지게 됩니다.